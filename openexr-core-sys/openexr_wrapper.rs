/* automatically generated by rust-bindgen 0.58.1 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
extern "C" {
    #[doc = " @brief Retrieve the current library version. The @p extra string is for"]
    #[doc = "  custom installs, and is a static string, do not free the returned pointer"]
    pub fn exr_get_library_version(
        maj: *mut ::std::os::raw::c_int,
        min: *mut ::std::os::raw::c_int,
        patch: *mut ::std::os::raw::c_int,
        extra: *mut *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " @brief Limit the size of image allowed to be parsed or created by"]
    #[doc = " the library"]
    #[doc = ""]
    #[doc = " This is used as a safety check against corrupt files, but can also"]
    #[doc = " serve to avoid potential issues on machines which have very"]
    #[doc = " constrained RAM"]
    #[doc = ""]
    #[doc = " These values are among the only globals in the core layer of"]
    #[doc = " OpenEXR. The intended use is for applications to define a global"]
    #[doc = " default, which will be combined with the values provided to the"]
    #[doc = " individual context creation routine. The values are used to check"]
    #[doc = " against parsed header values. This adds some level of safety from"]
    #[doc = " memory overruns where a corrupt file given to the system may cause"]
    #[doc = " a large allocation to happen, enabling buffer overruns or other"]
    #[doc = " potential security issue."]
    #[doc = ""]
    #[doc = " These global values are combined with the values in"]
    #[doc = " \\ref exr_context_initializer_t using the following rules:"]
    #[doc = ""]
    #[doc = " 1. negative values are ignored."]
    #[doc = ""]
    #[doc = " 2. if either value has a positive (non-zero) value, and the other"]
    #[doc = "    has 0, the positive value is preferred."]
    #[doc = ""]
    #[doc = " 3. If both are positive (non-zero), the minimum value is used."]
    #[doc = ""]
    #[doc = " 4. If both values are 0, this disables the constrained size checks."]
    #[doc = ""]
    #[doc = " This function does not fail."]
    pub fn exr_set_default_maximum_image_size(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Retrieve the global default maximum image size"]
    #[doc = ""]
    #[doc = " This function does not fail."]
    pub fn exr_get_default_maximum_image_size(
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Limit the size of an image tile allowed to be parsed or"]
    #[doc = " created by the library"]
    #[doc = ""]
    #[doc = " Similar to image size, this places constraints on the maximum tile"]
    #[doc = " size as a safety check against bad file data"]
    #[doc = ""]
    #[doc = " This is used as a safety check against corrupt files, but can also"]
    #[doc = " serve to avoid potential issues on machines which have very"]
    #[doc = " constrained RAM"]
    #[doc = ""]
    #[doc = " These values are among the only globals in the core layer of"]
    #[doc = " OpenEXR. The intended use is for applications to define a global"]
    #[doc = " default, which will be combined with the values provided to the"]
    #[doc = " individual context creation routine. The values are used to check"]
    #[doc = " against parsed header values. This adds some level of safety from"]
    #[doc = " memory overruns where a corrupt file given to the system may cause"]
    #[doc = " a large allocation to happen, enabling buffer overruns or other"]
    #[doc = " potential security issue."]
    #[doc = ""]
    #[doc = " These global values are combined with the values in"]
    #[doc = " \\ref exr_context_initializer_t using the following rules:"]
    #[doc = ""]
    #[doc = " 1. negative values are ignored."]
    #[doc = ""]
    #[doc = " 2. if either value has a positive (non-zero) value, and the other"]
    #[doc = " has 0, the positive value is preferred."]
    #[doc = ""]
    #[doc = " 3. If both are positive (non-zero), the minimum value is used."]
    #[doc = ""]
    #[doc = " 4. If both values are 0, this disables the constrained size checks."]
    #[doc = ""]
    #[doc = " This function does not fail."]
    pub fn exr_set_default_maximum_tile_size(
        w: ::std::os::raw::c_int,
        h: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Retrieve the global maximum tile size."]
    #[doc = ""]
    #[doc = " This function does not fail."]
    pub fn exr_get_default_maximum_tile_size(
        w: *mut ::std::os::raw::c_int,
        h: *mut ::std::os::raw::c_int,
    );
}
#[doc = " @brief function pointer used to hold a malloc-like routine"]
#[doc = ""]
#[doc = " Providing these to a context will override what memory is used to"]
#[doc = " allocate the context itself, as well as any allocations which"]
#[doc = " happen during processing of a file or stream. This can be used by"]
#[doc = " systems which provide rich malloc tracking routines to override the"]
#[doc = " internal allocations performed by the library."]
#[doc = ""]
#[doc = " This function is expected to allocate and return a new memory"]
#[doc = " handle, or NULL if allocation failed (which the library will then"]
#[doc = " handle and return an out-of-memory error)."]
#[doc = ""]
#[doc = " If one is provided, both should be provided."]
#[doc = " @sa exr_memory_free_func_t"]
pub type exr_memory_allocation_func_t = ::std::option::Option<
    unsafe extern "C" fn(bytes: size_t) -> *mut ::std::os::raw::c_void,
>;
#[doc = " @brief function pointer used to hold a free-like routine"]
#[doc = ""]
#[doc = " Providing these to a context will override what memory is used to"]
#[doc = " allocate the context itself, as well as any allocations which"]
#[doc = " happen during processing of a file or stream. This can be used by"]
#[doc = " systems which provide rich malloc tracking routines to override the"]
#[doc = " internal allocations performed by the library."]
#[doc = ""]
#[doc = " This function is expected to return memory to the system, ala free"]
#[doc = " from the C library."]
#[doc = ""]
#[doc = " If providing one, probably need to provide both routines."]
#[doc = " @sa exr_memory_allocation_func_t"]
pub type exr_memory_free_func_t = ::std::option::Option<
    unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " @brief Allows the user to override default allocator used internal allocations necessary for"]
    #[doc = " files, attributes, and other temporary memory."]
    #[doc = ""]
    #[doc = " These routines may be overridden when creating a specific context,"]
    #[doc = " however this provides global defaults such that the default can be"]
    #[doc = " applied."]
    #[doc = ""]
    #[doc = " If either pointer is 0, the appropriate malloc/free routine will be substituted."]
    #[doc = ""]
    #[doc = " This function does not fail."]
    pub fn exr_set_default_memory_routines(
        alloc_func: exr_memory_allocation_func_t,
        free_func: exr_memory_free_func_t,
    );
}
pub mod exr_error_code_t {
    #[doc = " error codes that may be returned by various functions"]
    pub type Type = ::std::os::raw::c_uint;
    pub const EXR_ERR_SUCCESS: Type = 0;
    pub const EXR_ERR_OUT_OF_MEMORY: Type = 1;
    pub const EXR_ERR_MISSING_CONTEXT_ARG: Type = 2;
    pub const EXR_ERR_INVALID_ARGUMENT: Type = 3;
    pub const EXR_ERR_ARGUMENT_OUT_OF_RANGE: Type = 4;
    pub const EXR_ERR_FILE_ACCESS: Type = 5;
    pub const EXR_ERR_FILE_BAD_HEADER: Type = 6;
    pub const EXR_ERR_NOT_OPEN_READ: Type = 7;
    pub const EXR_ERR_NOT_OPEN_WRITE: Type = 8;
    pub const EXR_ERR_HEADER_NOT_WRITTEN: Type = 9;
    pub const EXR_ERR_READ_IO: Type = 10;
    pub const EXR_ERR_WRITE_IO: Type = 11;
    pub const EXR_ERR_NAME_TOO_LONG: Type = 12;
    pub const EXR_ERR_MISSING_REQ_ATTR: Type = 13;
    pub const EXR_ERR_INVALID_ATTR: Type = 14;
    pub const EXR_ERR_NO_ATTR_BY_NAME: Type = 15;
    pub const EXR_ERR_ATTR_TYPE_MISMATCH: Type = 16;
    pub const EXR_ERR_ATTR_SIZE_MISMATCH: Type = 17;
    pub const EXR_ERR_SCAN_TILE_MIXEDAPI: Type = 18;
    pub const EXR_ERR_TILE_SCAN_MIXEDAPI: Type = 19;
    pub const EXR_ERR_MODIFY_SIZE_CHANGE: Type = 20;
    pub const EXR_ERR_ALREADY_WROTE_ATTRS: Type = 21;
    pub const EXR_ERR_BAD_CHUNK_LEADER: Type = 22;
    pub const EXR_ERR_CORRUPT_CHUNK: Type = 23;
    pub const EXR_ERR_INCORRECT_PART: Type = 24;
    pub const EXR_ERR_INCORRECT_CHUNK: Type = 25;
    pub const EXR_ERR_USE_SCAN_DEEP_WRITE: Type = 26;
    pub const EXR_ERR_USE_TILE_DEEP_WRITE: Type = 27;
    pub const EXR_ERR_USE_SCAN_NONDEEP_WRITE: Type = 28;
    pub const EXR_ERR_USE_TILE_NONDEEP_WRITE: Type = 29;
    pub const EXR_ERR_INVALID_SAMPLE_DATA: Type = 30;
    pub const EXR_ERR_FEATURE_NOT_IMPLEMENTED: Type = 31;
    pub const EXR_ERR_UNKNOWN: Type = 32;
}
extern "C" {
    #[doc = " @brief Return a static string corresponding to the specified error code"]
    #[doc = ""]
    #[doc = " The string should not be freed (it is compiled into the binary)."]
    pub fn exr_get_default_error_message(
        code: exr_result_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return a static string corresponding to the specified error code"]
    #[doc = ""]
    #[doc = " The string should not be freed (it is compiled into the binary)."]
    pub fn exr_get_error_code_as_string(
        code: exr_result_t,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _priv_exr_context_t {
    _unused: [u8; 0],
}
#[doc = " Opaque context handle"]
#[doc = ""]
#[doc = " The implementation of this is partly opaque to provide better"]
#[doc = " version portability, and all accesses to relevant data should"]
#[doc = " happen using provided functions. This handle serves as a container"]
#[doc = " and identifier for all the metadata and parts associated with a"]
#[doc = " file and/or stream"]
pub type exr_context_t = *mut _priv_exr_context_t;
pub type exr_const_context_t = *const _priv_exr_context_t;
#[doc = " @brief Stream error notifier"]
#[doc = ""]
#[doc = "  This function pointer is provided to the stream functions by the"]
#[doc = "  library such that they can provide a nice error message to the"]
#[doc = "  user during stream operations."]
pub type exr_stream_error_func_ptr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        code: exr_result_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> exr_result_t,
>;
#[doc = " @brief Error callback function"]
#[doc = ""]
#[doc = "  Because a file can be read from using many threads at once, it is"]
#[doc = "  difficult to store an error message for later retrieval. As such,"]
#[doc = "  when a file is constructed, a callback function can be provided"]
#[doc = "  which delivers an error message for the calling application to"]
#[doc = "  handle. This will then be delivered on the same thread causing the"]
#[doc = "  error."]
pub type exr_error_handler_cb_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        code: exr_result_t,
        msg: *const ::std::os::raw::c_char,
    ),
>;
#[doc = " Destroy custom stream function pointer"]
#[doc = ""]
#[doc = "  Generic callback to clean up user data for custom streams."]
#[doc = "  This is called when the file is closed and expected not to"]
#[doc = "  error"]
#[doc = ""]
#[doc = "  @param failed - indicates the write operation failed, the"]
#[doc = "                  implementor may wish to cleanup temporary"]
#[doc = "                  files"]
pub type exr_destroy_stream_func_ptr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        userdata: *mut ::std::os::raw::c_void,
        failed: ::std::os::raw::c_int,
    ),
>;
#[doc = " Query stream size function pointer"]
#[doc = ""]
#[doc = " Used to query the size of the file, or amount of data representing"]
#[doc = " the openexr file in the data stream."]
#[doc = ""]
#[doc = " This is used to validate requests against the file. If the size is"]
#[doc = " unavailable, return -1, which will disable these validation steps"]
#[doc = " for this file, although appropriate memory safeguards must be in"]
#[doc = " place in the calling application."]
pub type exr_query_size_func_ptr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        userdata: *mut ::std::os::raw::c_void,
    ) -> i64,
>;
#[doc = " @brief Read custom function pointer"]
#[doc = ""]
#[doc = " Used to read data from a custom output. Expects similar semantics to"]
#[doc = " pread or ReadFile with overlapped data under win32"]
#[doc = ""]
#[doc = " It is required that this provides thread-safe concurrent access to"]
#[doc = " the same file. If the stream / input layer you are providing does"]
#[doc = " not have this guarantee, your are responsible for providing"]
#[doc = " appropriate serialization of requests."]
#[doc = ""]
#[doc = " A file should be expected to be accessed in the following pattern:"]
#[doc = "  - upon open, the header and part information attributes will be read"]
#[doc = "  - upon the first image read request, the offset tables will be read"]
#[doc = "    multiple threads accessing this concurrently may actually read"]
#[doc = "    these values at the same time"]
#[doc = "  - chunks can then be read in any order as preferred by the"]
#[doc = "    application"]
#[doc = ""]
#[doc = " While this should mean that the header will be read in 'stream'"]
#[doc = " order (no seeks required), no guarantee is made beyond that to"]
#[doc = " retrieve image / deep data in order. So if the backing file is"]
#[doc = " truly a stream, it is up to the provider to implement appropriate"]
#[doc = " caching of data to give the appearance of being able to seek / read"]
#[doc = " atomically."]
pub type exr_read_func_ptr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        userdata: *mut ::std::os::raw::c_void,
        buffer: *mut ::std::os::raw::c_void,
        sz: u64,
        offset: u64,
        error_cb: exr_stream_error_func_ptr_t,
    ) -> i64,
>;
#[doc = " Write custom function pointer"]
#[doc = ""]
#[doc = "  Used to write data to a custom output. Expects similar semantics to"]
#[doc = "  pwrite or WriteFile with overlapped data under win32"]
#[doc = ""]
#[doc = "  It is required that this provides thread-safe concurrent access to"]
#[doc = "  the same file. While it is unlikely that multiple threads will"]
#[doc = "  be used to write data for compressed forms, it is possible."]
#[doc = ""]
#[doc = "  A file should be expected to be accessed in the following pattern:"]
#[doc = "  - upon open, the header and part information attributes is constructed"]
#[doc = ""]
#[doc = "  - when the write_header routine is called, the header becomes immutable"]
#[doc = "    and is written to the file. This computes the space to store the chunk"]
#[doc = "    offsets, but does not yet write the values"]
#[doc = ""]
#[doc = "  - Image chunks are written to the file, and appear in the order"]
#[doc = "    they are written, not in the ordering that is required by the"]
#[doc = "    chunk offset table (unless written in that order). This may vary"]
#[doc = "    slightly if the size of the chunks is not directly known and"]
#[doc = "    tight packing of data is necessary"]
#[doc = ""]
#[doc = "  - at file close, the chunk offset tables are written to the file"]
pub type exr_write_func_ptr_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctxt: exr_const_context_t,
        userdata: *mut ::std::os::raw::c_void,
        buffer: *const ::std::os::raw::c_void,
        sz: u64,
        offset: u64,
        error_cb: exr_stream_error_func_ptr_t,
    ) -> i64,
>;
#[doc = " @brief struct used to pass function pointers into the context"]
#[doc = " initialization routines."]
#[doc = ""]
#[doc = " This partly exists to avoid the chicken and egg issue around creating the storage needed for the context on systems which want to override the malloc / free routines."]
#[doc = ""]
#[doc = " However, it also serves to make a tidier / simpler set of functions"]
#[doc = " to create and start processing exr files."]
#[doc = ""]
#[doc = " The size member is required for version portability"]
#[doc = ""]
#[doc = " It can be initialized using \\ref EXR_DEFAULT_CONTEXT_INITIALIZER"]
#[doc = ""]
#[doc = " \\code{.c}"]
#[doc = " exr_context_initializer_t myctxtinit = DEFAULT_CONTEXT_INITIALIZER;"]
#[doc = " myctxtinit.error_cb = &my_super_cool_error_callback_function;"]
#[doc = " ..."]
#[doc = " \\endcode"]
#[doc = ""]
#[repr(C)]
pub struct _exr_context_initializer {
    #[doc = " @brief size member to tag initializer for version stability."]
    #[doc = ""]
    #[doc = " This should be initialized to the size of the current"]
    #[doc = " structure. This allows EXR to add functions or other"]
    #[doc = " initializers in the future, and retain version compatibility"]
    pub size: size_t,
    #[doc = " @brief Error callback function pointer"]
    #[doc = ""]
    #[doc = " The error callback is allowed to be null, and will use a default print which outputs to stderr"]
    #[doc = ""]
    #[doc = " @sa exr_error_handler_cb_t"]
    pub error_handler_fn: exr_error_handler_cb_t,
    #[doc = " custom allocator, if null, will use malloc. @sa exr_memory_allocation_func_t"]
    pub alloc_fn: exr_memory_allocation_func_t,
    #[doc = " custom deallocator, if null, will use free. @sa exr_memory_free_func_t"]
    pub free_fn: exr_memory_free_func_t,
    #[doc = " passed to custom read, size, write, destroy functions below. Up to user to manage this pointer"]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = " @brief custom read routine."]
    #[doc = ""]
    #[doc = " This is only used during read or update contexts. If this is"]
    #[doc = " provided, it is expected that the caller has previously made"]
    #[doc = " the stream available, and placed whatever stream / file data"]
    #[doc = " into \\ref user_data above."]
    #[doc = ""]
    #[doc = " If this is NULL, and the context requested is for reading an"]
    #[doc = " exr file, an internal implementation is provided for reading"]
    #[doc = " from normal filesystem files, and the filename provided is"]
    #[doc = " attempted to be opened as such."]
    #[doc = ""]
    #[doc = " Expected to be NULL for a write-only operation, but is ignored"]
    #[doc = " if it is provided."]
    #[doc = ""]
    #[doc = " For update contexts, both read and write functions must be"]
    #[doc = " provided if either is."]
    #[doc = ""]
    #[doc = " @sa exr_read_func_ptr_t"]
    pub read_fn: exr_read_func_ptr_t,
    #[doc = " @brief custom size query routine."]
    #[doc = ""]
    #[doc = " Used to provide validation when reading header values. If this"]
    #[doc = " is not provided, but a custom read routine is provided, this"]
    #[doc = " will disable some of the validation checks when parsing the"]
    #[doc = " image header."]
    #[doc = ""]
    #[doc = " Expected to be NULL for a write-only operation, but is ignored"]
    #[doc = " if it is provided."]
    #[doc = ""]
    #[doc = " @sa exr_query_size_func_ptr_t"]
    pub size_fn: exr_query_size_func_ptr_t,
    #[doc = " @brief custom write routine."]
    #[doc = ""]
    #[doc = " This is only used during write or update contexts. If this is"]
    #[doc = " provided, it is expected that the caller has previously made"]
    #[doc = " the stream available, and placed whatever stream / file data"]
    #[doc = " into \\ref user_data above."]
    #[doc = ""]
    #[doc = " If this is NULL, and the context requested is for writing an"]
    #[doc = " exr file, an internal implementation is provided for reading"]
    #[doc = " from normal filesystem files, and the filename provided is"]
    #[doc = " attempted to be opened as such."]
    #[doc = ""]
    #[doc = " For update contexts, both read and write functions must be"]
    #[doc = " provided if either is."]
    #[doc = ""]
    #[doc = " @sa exr_write_func_ptr_t"]
    pub write_fn: exr_write_func_ptr_t,
    #[doc = " @brief optional function to destroy the user data block of a custom stream"]
    #[doc = ""]
    #[doc = " Allows one to free any user allocated data, and close any handles."]
    #[doc = ""]
    #[doc = " @sa exr_destroy_stream_func_ptr_t"]
    pub destroy_fn: exr_destroy_stream_func_ptr_t,
    #[doc = " initializes a field specifying what the maximum image width"]
    #[doc = " allowed by the context is. See \\ref exr_set_default_maximum_image_size to"]
    #[doc = " understand how this interacts with global defaults"]
    pub max_image_width: ::std::os::raw::c_int,
    #[doc = " initializes a field specifying what the maximum image height"]
    #[doc = " allowed by the context is. See \\ref exr_set_default_maximum_image_size to"]
    #[doc = " understand how this interacts with global defaults"]
    pub max_image_height: ::std::os::raw::c_int,
    #[doc = " initializes a field specifying what the maximum tile width"]
    #[doc = " allowed by the context is. See \\ref exr_set_default_maximum_tile_size to"]
    #[doc = " understand how this interacts with global defaults"]
    pub max_tile_width: ::std::os::raw::c_int,
    #[doc = " initializes a field specifying what the maximum tile height"]
    #[doc = " allowed by the context is. See \\ref exr_set_default_maximum_tile_size to"]
    #[doc = " understand how this interacts with global defaults"]
    pub max_tile_height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__exr_context_initializer() {
    assert_eq!(
        ::std::mem::size_of::<_exr_context_initializer>(),
        88usize,
        concat!("Size of: ", stringify!(_exr_context_initializer))
    );
    assert_eq!(
        ::std::mem::align_of::<_exr_context_initializer>(),
        8usize,
        concat!("Alignment of ", stringify!(_exr_context_initializer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_context_initializer>())).size
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_context_initializer>()))
                .error_handler_fn as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer),
            "::",
            stringify!(error_handler_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_context_initializer>())).alloc_fn
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer),
            "::",
            stringify!(alloc_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_context_initializer>())).free_fn
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer),
            "::",
            stringify!(free_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_context_initializer>())).user_data
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_context_initializer>())).read_fn
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer),
            "::",
            stringify!(read_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_context_initializer>())).size_fn
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer),
            "::",
            stringify!(size_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_context_initializer>())).write_fn
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer),
            "::",
            stringify!(write_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_context_initializer>())).destroy_fn
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer),
            "::",
            stringify!(destroy_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_context_initializer>())).max_image_width
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer),
            "::",
            stringify!(max_image_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_context_initializer>()))
                .max_image_height as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer),
            "::",
            stringify!(max_image_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_context_initializer>())).max_tile_width
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer),
            "::",
            stringify!(max_tile_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_context_initializer>())).max_tile_height
                as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_context_initializer),
            "::",
            stringify!(max_tile_height)
        )
    );
}
#[doc = " @brief struct used to pass function pointers into the context"]
#[doc = " initialization routines."]
#[doc = ""]
#[doc = " This partly exists to avoid the chicken and egg issue around creating the storage needed for the context on systems which want to override the malloc / free routines."]
#[doc = ""]
#[doc = " However, it also serves to make a tidier / simpler set of functions"]
#[doc = " to create and start processing exr files."]
#[doc = ""]
#[doc = " The size member is required for version portability"]
#[doc = ""]
#[doc = " It can be initialized using \\ref EXR_DEFAULT_CONTEXT_INITIALIZER"]
#[doc = ""]
#[doc = " \\code{.c}"]
#[doc = " exr_context_initializer_t myctxtinit = DEFAULT_CONTEXT_INITIALIZER;"]
#[doc = " myctxtinit.error_cb = &my_super_cool_error_callback_function;"]
#[doc = " ..."]
#[doc = " \\endcode"]
#[doc = ""]
pub type exr_context_initializer_t = _exr_context_initializer;
extern "C" {
    #[doc = " @brief Check the magic number of the file and report"]
    #[doc = " `EXR_ERR_SUCCESS` if the file appears to be a valid file (or at least"]
    #[doc = " has the correct magic number and can be read)"]
    pub fn exr_test_file_header(
        filename: *const ::std::os::raw::c_char,
        ctxtdata: *const exr_context_initializer_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Close and free any internally allocated memory,"]
    #[doc = " calling any provided destroy function for custom streams"]
    #[doc = ""]
    #[doc = " If the file was opened for write, first save the chunk offsets"]
    #[doc = " or any other unwritten data."]
    pub fn exr_finish(ctxt: *mut exr_context_t) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Create and initialize a read-only exr read context"]
    #[doc = ""]
    #[doc = " If a custom read function is provided, the filename is for"]
    #[doc = " informational purposes only, the system assumes the user has"]
    #[doc = " previously opened a stream, file, or whatever and placed relevant"]
    #[doc = " data in userdata to access that."]
    #[doc = ""]
    #[doc = " One notable attribute of the context is that once it has been"]
    #[doc = " created and returned a successful code, it has parsed all the"]
    #[doc = " header data. This is done as one step such that it is easier to"]
    #[doc = " provide a safe context for multiple threads to request data from"]
    #[doc = " the same context concurrently."]
    #[doc = ""]
    #[doc = " Once finished reading data, use \\ref exr_finish to clean up"]
    #[doc = " the context."]
    #[doc = ""]
    #[doc = " If you have custom I/O requirements, see the initializer context"]
    #[doc = " documentation \\ref exr_context_initializer_t. The @p ctxtdata parameter"]
    #[doc = " is optional, if `NULL`, default values will be used."]
    pub fn exr_start_read(
        ctxt: *mut exr_context_t,
        filename: *const ::std::os::raw::c_char,
        ctxtdata: *const exr_context_initializer_t,
    ) -> exr_result_t;
}
impl exr_default_write_mode {
    pub const EXR_WRITE_FILE_DIRECTLY: exr_default_write_mode =
        exr_default_write_mode(0);
}
impl exr_default_write_mode {
    pub const EXR_INTERMEDIATE_TEMP_FILE: exr_default_write_mode =
        exr_default_write_mode(1);
}
#[repr(transparent)]
#[doc = " @brief enum describing how default files are handled during write"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_default_write_mode(pub ::std::os::raw::c_uint);
extern "C" {
    #[doc = " @brief Creates and initializes a write-only context."]
    #[doc = ""]
    #[doc = " If a custom write function is provided, the filename is for"]
    #[doc = " informational purposes only, and the @p default_mode parameter will be"]
    #[doc = " ignored. As such, the system assumes the user has previously opened"]
    #[doc = " a stream, file, or whatever and placed relevant data in userdata to"]
    #[doc = " access that."]
    #[doc = ""]
    #[doc = " Multi-Threading: To avoid issues with creating multi-part EXR"]
    #[doc = " files, the library approaches writing as a multi-step process, so"]
    #[doc = " the same concurrent guarantees can not be made for writing a"]
    #[doc = " file. The steps are:"]
    #[doc = ""]
    #[doc = " 1. Context creation (this function)"]
    #[doc = ""]
    #[doc = " 2. Part definition (required attributes and additional metadata)"]
    #[doc = ""]
    #[doc = " 3. Transition to writing data (this \"commits\" the part definitions,"]
    #[doc = " any changes requested after will result in an error)"]
    #[doc = ""]
    #[doc = " 4. Write part data in sequential order of parts ( part 0->(N-1) )."]
    #[doc = ""]
    #[doc = " 5. Within each part, multiple threads can be encoding and writing"]
    #[doc = " data concurrently. For some EXR part definitions, this may be able"]
    #[doc = " to write data concurrently when it can predict the chunk sizes, or"]
    #[doc = " data is allowed to be padded. For others, it may need to"]
    #[doc = " temporarily cache chunks until the data is received to flush in"]
    #[doc = " order. The concurrency around this is handled by the library"]
    #[doc = ""]
    #[doc = " 6. Once finished writing data, use \\ref exr_finish to clean"]
    #[doc = " up the context, which will flush any unwritten data such as the"]
    #[doc = " final chunk offset tables, and handle the temporary file flags."]
    #[doc = ""]
    #[doc = " If you have custom I/O requirements, see the initializer context"]
    #[doc = " documentation \\ref exr_context_initializer_t. The @p ctxtdata"]
    #[doc = " parameter is optional, if NULL, default values will be used."]
    pub fn exr_start_write(
        ctxt: *mut exr_context_t,
        filename: *const ::std::os::raw::c_char,
        default_mode: exr_default_write_mode,
        ctxtdata: *const exr_context_initializer_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Creates a new context for updating an exr file in place"]
    #[doc = ""]
    #[doc = " This is a custom mode that allows one to modify the value of a"]
    #[doc = " metadata entry, although not to change the size of the header, or"]
    #[doc = " any of the image data."]
    #[doc = ""]
    #[doc = " If you have custom I/O requirements, see the initializer context"]
    #[doc = " documentation \\ref exr_context_initializer_t. The @p ctxtdata parameter"]
    #[doc = " is optional, if NULL, default values will be used."]
    pub fn exr_start_inplace_header_update(
        ctxt: *mut exr_context_t,
        filename: *const ::std::os::raw::c_char,
        ctxtdata: *const exr_context_initializer_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the file name the context is for as provided"]
    #[doc = " during the start routine."]
    #[doc = ""]
    #[doc = " Do not free the resulting string."]
    pub fn exr_get_file_name(
        ctxt: exr_const_context_t,
        name: *mut *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query the user data the context was constructed with. This"]
    #[doc = " is perhaps useful in the error handler callback to jump back into"]
    #[doc = " an object the user controls."]
    pub fn exr_get_user_data(
        ctxt: exr_const_context_t,
        userdata: *mut *mut ::std::os::raw::c_void,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Any opaque attribute data entry of the specified type is tagged"]
    #[doc = " with these functions enabling downstream users to unpack (or pack)"]
    #[doc = " the data."]
    #[doc = ""]
    #[doc = " The library handles the memory packed data internally, but the"]
    #[doc = " handler is expected to allocate and manage memory for the"]
    #[doc = " *unpacked* buffer (the library will call the destroy function)."]
    #[doc = ""]
    #[doc = " NB: the pack function will be called twice (unless there is a"]
    #[doc = " memory failure), the first with a NULL buffer, requesting the"]
    #[doc = " maximum size (or exact size if known) for the packed buffer, then"]
    #[doc = " the second to fill the output packed buffer, at which point the"]
    #[doc = " size can be re-updated to have the final, precise size to put into"]
    #[doc = " the file."]
    pub fn exr_register_attr_type_handler(
        ctxt: exr_context_t,
        type_: *const ::std::os::raw::c_char,
        unpack_func_ptr: ::std::option::Option<
            unsafe extern "C" fn(
                ctxt: exr_context_t,
                data: *const ::std::os::raw::c_void,
                attrsize: i32,
                outsize: *mut i32,
                outbuffer: *mut *mut ::std::os::raw::c_void,
            ) -> exr_result_t,
        >,
        pack_func_ptr: ::std::option::Option<
            unsafe extern "C" fn(
                ctxt: exr_context_t,
                data: *const ::std::os::raw::c_void,
                datasize: i32,
                outsize: *mut i32,
                outbuffer: *mut ::std::os::raw::c_void,
            ) -> exr_result_t,
        >,
        destroy_unpacked_func_ptr: ::std::option::Option<
            unsafe extern "C" fn(
                ctxt: exr_context_t,
                data: *mut ::std::os::raw::c_void,
                datasize: i32,
            ),
        >,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Enable long name support in the output context"]
    pub fn exr_set_longname_support(
        ctxt: exr_context_t,
        onoff: ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Write the header data"]
    #[doc = ""]
    #[doc = " Opening a new output file has a small initialization state problem"]
    #[doc = " compared to opening for read / update: we need to enable the user"]
    #[doc = " to specify an arbitrary set of metadata across an arbitrary number"]
    #[doc = " of parts. To avoid having to create the list of parts and entire"]
    #[doc = " metadata up front, prior to calling the above \\ref exr_start_write,"]
    #[doc = " allow the data to be set, then once this is called, it switches"]
    #[doc = " into a mode where the library assumes the data is now valid."]
    #[doc = ""]
    #[doc = " It will recompute the number of chunks that will be written, and"]
    #[doc = " reset the chunk offsets. If you modify file attributes or part"]
    #[doc = " information after a call to this, it will error."]
    pub fn exr_write_header(ctxt: exr_context_t) -> exr_result_t;
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_NONE: exr_compression_t = exr_compression_t(0);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_RLE: exr_compression_t = exr_compression_t(1);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_ZIPS: exr_compression_t = exr_compression_t(2);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_ZIP: exr_compression_t = exr_compression_t(3);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_PIZ: exr_compression_t = exr_compression_t(4);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_PXR24: exr_compression_t = exr_compression_t(5);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_B44: exr_compression_t = exr_compression_t(6);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_B44A: exr_compression_t = exr_compression_t(7);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_DWAA: exr_compression_t = exr_compression_t(8);
}
impl exr_compression_t {
    pub const EXR_COMPRESSION_DWAB: exr_compression_t = exr_compression_t(9);
}
impl exr_compression_t {
    #[doc = "< invalid value, provided for range checking"]
    pub const EXR_COMPRESSION_LAST_TYPE: exr_compression_t =
        exr_compression_t(10);
}
#[repr(transparent)]
#[doc = " enum declaring allowed values for uint8_t value stored in built-in compression type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_compression_t(pub ::std::os::raw::c_uint);
impl exr_envmap_t {
    pub const EXR_ENVMAP_LATLONG: exr_envmap_t = exr_envmap_t(0);
}
impl exr_envmap_t {
    pub const EXR_ENVMAP_CUBE: exr_envmap_t = exr_envmap_t(1);
}
impl exr_envmap_t {
    #[doc = "< invalid value, provided for range checking"]
    pub const EXR_ENVMAP_LAST_TYPE: exr_envmap_t = exr_envmap_t(2);
}
#[repr(transparent)]
#[doc = " enum declaring allowed values for uint8_t value stored in built-in env map type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_envmap_t(pub ::std::os::raw::c_uint);
impl exr_lineorder_t {
    pub const EXR_LINEORDER_INCREASING_Y: exr_lineorder_t = exr_lineorder_t(0);
}
impl exr_lineorder_t {
    pub const EXR_LINEORDER_DECREASING_Y: exr_lineorder_t = exr_lineorder_t(1);
}
impl exr_lineorder_t {
    pub const EXR_LINEORDER_RANDOM_Y: exr_lineorder_t = exr_lineorder_t(2);
}
impl exr_lineorder_t {
    #[doc = "< invalid value, provided for range checking"]
    pub const EXR_LINEORDER_LAST_TYPE: exr_lineorder_t = exr_lineorder_t(3);
}
#[repr(transparent)]
#[doc = " enum declaring allowed values for uint8_t value stored in lineOrder type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_lineorder_t(pub ::std::os::raw::c_uint);
impl exr_storage_t {
    #[doc = "< corresponds to type of 'scanlineimage'"]
    pub const EXR_STORAGE_SCANLINE: exr_storage_t = exr_storage_t(0);
}
impl exr_storage_t {
    #[doc = "< corresponds to type of 'tiledimage'"]
    pub const EXR_STORAGE_TILED: exr_storage_t = exr_storage_t(1);
}
impl exr_storage_t {
    #[doc = "< corresponds to type of 'deepscanline'"]
    pub const EXR_STORAGE_DEEP_SCANLINE: exr_storage_t = exr_storage_t(2);
}
impl exr_storage_t {
    #[doc = "< corresponds to type of 'deeptile'"]
    pub const EXR_STORAGE_DEEP_TILED: exr_storage_t = exr_storage_t(3);
}
impl exr_storage_t {
    #[doc = "< invalid value, provided for range checking"]
    pub const EXR_STORAGE_LAST_TYPE: exr_storage_t = exr_storage_t(4);
}
#[repr(transparent)]
#[doc = " enum declaring allowed values for part type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_storage_t(pub ::std::os::raw::c_uint);
impl exr_tile_level_mode_t {
    #[doc = "< single level of image data"]
    pub const EXR_TILE_ONE_LEVEL: exr_tile_level_mode_t =
        exr_tile_level_mode_t(0);
}
impl exr_tile_level_mode_t {
    #[doc = "< mipmapped image data"]
    pub const EXR_TILE_MIPMAP_LEVELS: exr_tile_level_mode_t =
        exr_tile_level_mode_t(1);
}
impl exr_tile_level_mode_t {
    #[doc = "< ripmapped image data"]
    pub const EXR_TILE_RIPMAP_LEVELS: exr_tile_level_mode_t =
        exr_tile_level_mode_t(2);
}
impl exr_tile_level_mode_t {
    #[doc = "< guard / out of range type"]
    pub const EXR_TILE_LAST_TYPE: exr_tile_level_mode_t =
        exr_tile_level_mode_t(3);
}
#[repr(transparent)]
#[doc = " @brief Enum representing what type of tile information is contained"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_tile_level_mode_t(pub ::std::os::raw::c_uint);
impl exr_tile_round_mode_t {
    pub const EXR_TILE_ROUND_DOWN: exr_tile_round_mode_t =
        exr_tile_round_mode_t(0);
}
impl exr_tile_round_mode_t {
    pub const EXR_TILE_ROUND_UP: exr_tile_round_mode_t =
        exr_tile_round_mode_t(1);
}
impl exr_tile_round_mode_t {
    pub const EXR_TILE_ROUND_LAST_TYPE: exr_tile_round_mode_t =
        exr_tile_round_mode_t(2);
}
#[repr(transparent)]
#[doc = " @brief Enum representing how to scale positions between levels"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_tile_round_mode_t(pub ::std::os::raw::c_uint);
impl exr_pixel_type_t {
    pub const EXR_PIXEL_UINT: exr_pixel_type_t = exr_pixel_type_t(0);
}
impl exr_pixel_type_t {
    pub const EXR_PIXEL_HALF: exr_pixel_type_t = exr_pixel_type_t(1);
}
impl exr_pixel_type_t {
    pub const EXR_PIXEL_FLOAT: exr_pixel_type_t = exr_pixel_type_t(2);
}
impl exr_pixel_type_t {
    pub const EXR_PIXEL_LAST_TYPE: exr_pixel_type_t = exr_pixel_type_t(3);
}
#[repr(transparent)]
#[doc = " @brief Enum capturing the underlying data type on a channel"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_pixel_type_t(pub ::std::os::raw::c_uint);
#[doc = " @brief struct to hold color chromaticities to interpret the tristimulus color values in the image data"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_chromaticities_t {
    pub red_x: f32,
    pub red_y: f32,
    pub green_x: f32,
    pub green_y: f32,
    pub blue_x: f32,
    pub blue_y: f32,
    pub white_x: f32,
    pub white_y: f32,
}
#[test]
fn bindgen_test_layout_exr_attr_chromaticities_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_chromaticities_t>(),
        32usize,
        concat!("Size of: ", stringify!(exr_attr_chromaticities_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_chromaticities_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_chromaticities_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chromaticities_t>())).red_x
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chromaticities_t),
            "::",
            stringify!(red_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chromaticities_t>())).red_y
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chromaticities_t),
            "::",
            stringify!(red_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chromaticities_t>())).green_x
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chromaticities_t),
            "::",
            stringify!(green_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chromaticities_t>())).green_y
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chromaticities_t),
            "::",
            stringify!(green_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chromaticities_t>())).blue_x
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chromaticities_t),
            "::",
            stringify!(blue_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chromaticities_t>())).blue_y
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chromaticities_t),
            "::",
            stringify!(blue_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chromaticities_t>())).white_x
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chromaticities_t),
            "::",
            stringify!(white_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chromaticities_t>())).white_y
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chromaticities_t),
            "::",
            stringify!(white_y)
        )
    );
}
#[doc = " @brief struct to hold keycode information"]
#[repr(C, packed)]
pub struct exr_attr_keycode_t {
    pub film_mfc_code: i32,
    pub film_type: i32,
    pub prefix: i32,
    pub count: i32,
    pub perf_offset: i32,
    pub perfs_per_frame: i32,
    pub perfs_per_count: i32,
}
#[test]
fn bindgen_test_layout_exr_attr_keycode_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_keycode_t>(),
        28usize,
        concat!("Size of: ", stringify!(exr_attr_keycode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_keycode_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_keycode_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_keycode_t>())).film_mfc_code
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_keycode_t),
            "::",
            stringify!(film_mfc_code)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_keycode_t>())).film_type as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_keycode_t),
            "::",
            stringify!(film_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_keycode_t>())).prefix as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_keycode_t),
            "::",
            stringify!(prefix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_keycode_t>())).count as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_keycode_t),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_keycode_t>())).perf_offset
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_keycode_t),
            "::",
            stringify!(perf_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_keycode_t>())).perfs_per_frame
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_keycode_t),
            "::",
            stringify!(perfs_per_frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_keycode_t>())).perfs_per_count
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_keycode_t),
            "::",
            stringify!(perfs_per_count)
        )
    );
}
#[doc = " @brief struct to hold a 32-bit floating-point 3x3 matrix"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_m33f_t {
    pub m: [f32; 9usize],
}
#[test]
fn bindgen_test_layout_exr_attr_m33f_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_m33f_t>(),
        36usize,
        concat!("Size of: ", stringify!(exr_attr_m33f_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_m33f_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_m33f_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_m33f_t>())).m as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_m33f_t),
            "::",
            stringify!(m)
        )
    );
}
#[doc = " @brief struct to hold a 64-bit floating-point 3x3 matrix"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_m33d_t {
    pub m: [f64; 9usize],
}
#[test]
fn bindgen_test_layout_exr_attr_m33d_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_m33d_t>(),
        72usize,
        concat!("Size of: ", stringify!(exr_attr_m33d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_m33d_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_m33d_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_m33d_t>())).m as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_m33d_t),
            "::",
            stringify!(m)
        )
    );
}
#[doc = " @brief struct to hold a 32-bit floating-point 4x4 matrix"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_m44f_t {
    pub m: [f32; 16usize],
}
#[test]
fn bindgen_test_layout_exr_attr_m44f_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_m44f_t>(),
        64usize,
        concat!("Size of: ", stringify!(exr_attr_m44f_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_m44f_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_m44f_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_m44f_t>())).m as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_m44f_t),
            "::",
            stringify!(m)
        )
    );
}
#[doc = " @brief struct to hold a 64-bit floating-point 4x4 matrix"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_m44d_t {
    pub m: [f64; 16usize],
}
#[test]
fn bindgen_test_layout_exr_attr_m44d_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_m44d_t>(),
        128usize,
        concat!("Size of: ", stringify!(exr_attr_m44d_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_m44d_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_m44d_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_m44d_t>())).m as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_m44d_t),
            "::",
            stringify!(m)
        )
    );
}
#[doc = " @brief struct to hold an integer ratio value"]
#[repr(C, packed)]
pub struct exr_attr_rational_t {
    pub num: i32,
    pub denom: u32,
}
#[test]
fn bindgen_test_layout_exr_attr_rational_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_rational_t>(),
        8usize,
        concat!("Size of: ", stringify!(exr_attr_rational_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_rational_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_rational_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_rational_t>())).num as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_rational_t),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_rational_t>())).denom as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_rational_t),
            "::",
            stringify!(denom)
        )
    );
}
#[doc = " @brief struct to hold timecode information"]
#[repr(C, packed)]
pub struct exr_attr_timecode_t {
    pub time_and_flags: u32,
    pub user_data: u32,
}
#[test]
fn bindgen_test_layout_exr_attr_timecode_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_timecode_t>(),
        8usize,
        concat!("Size of: ", stringify!(exr_attr_timecode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_timecode_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_timecode_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_timecode_t>())).time_and_flags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_timecode_t),
            "::",
            stringify!(time_and_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_timecode_t>())).user_data
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_timecode_t),
            "::",
            stringify!(user_data)
        )
    );
}
#[repr(C, packed)]
pub struct exr_attr_v2i_t__bindgen_ty_1 {
    pub __bindgen_anon_1:
        __BindgenUnionField<exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1>,
    pub arr: __BindgenUnionField<[i32; 2usize]>,
    pub bindgen_union_field: [u8; 8usize],
}
#[repr(C, packed)]
pub struct exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1 {
    pub x: i32,
    pub y: i32,
}
#[test]
fn bindgen_test_layout_exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .y as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v2i_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout_exr_attr_v2i_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v2i_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(exr_attr_v2i_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v2i_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v2i_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v2i_t__bindgen_ty_1>())).arr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v2i_t__bindgen_ty_1),
            "::",
            stringify!(arr)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union exr_attr_v2f_t__bindgen_ty_1 {
    pub __bindgen_anon_1: exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1,
    pub arr: [f32; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .y as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v2f_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout_exr_attr_v2f_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v2f_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(exr_attr_v2f_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v2f_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v2f_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v2f_t__bindgen_ty_1>())).arr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v2f_t__bindgen_ty_1),
            "::",
            stringify!(arr)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union exr_attr_v2d_t__bindgen_ty_1 {
    pub __bindgen_anon_1: exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1,
    pub arr: [f64; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1 {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .y as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v2d_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
}
#[test]
fn bindgen_test_layout_exr_attr_v2d_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v2d_t__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_v2d_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v2d_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v2d_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v2d_t__bindgen_ty_1>())).arr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v2d_t__bindgen_ty_1),
            "::",
            stringify!(arr)
        )
    );
}
#[repr(C, packed)]
pub struct exr_attr_v3i_t__bindgen_ty_1 {
    pub __bindgen_anon_1:
        __BindgenUnionField<exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1>,
    pub arr: __BindgenUnionField<[i32; 3usize]>,
    pub bindgen_union_field: [u8; 12usize],
}
#[repr(C, packed)]
pub struct exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1 {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
#[test]
fn bindgen_test_layout_exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .y as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .z as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v3i_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(z)
        )
    );
}
#[test]
fn bindgen_test_layout_exr_attr_v3i_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v3i_t__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(exr_attr_v3i_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v3i_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v3i_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v3i_t__bindgen_ty_1>())).arr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v3i_t__bindgen_ty_1),
            "::",
            stringify!(arr)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union exr_attr_v3f_t__bindgen_ty_1 {
    pub __bindgen_anon_1: exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1,
    pub arr: [f32; 3usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
#[test]
fn bindgen_test_layout_exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .y as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .z as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v3f_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(z)
        )
    );
}
#[test]
fn bindgen_test_layout_exr_attr_v3f_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v3f_t__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(exr_attr_v3f_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v3f_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v3f_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v3f_t__bindgen_ty_1>())).arr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v3f_t__bindgen_ty_1),
            "::",
            stringify!(arr)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union exr_attr_v3d_t__bindgen_ty_1 {
    pub __bindgen_anon_1: exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1,
    pub arr: [f64; 3usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1 {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .x as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .y as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1>(
            )))
            .z as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v3d_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(z)
        )
    );
}
#[test]
fn bindgen_test_layout_exr_attr_v3d_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_v3d_t__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(exr_attr_v3d_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_v3d_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_v3d_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_v3d_t__bindgen_ty_1>())).arr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_v3d_t__bindgen_ty_1),
            "::",
            stringify!(arr)
        )
    );
}
#[doc = " @brief struct to hold an integer box / region definition"]
#[repr(C)]
pub struct exr_attr_box2i_t {
    pub min: exr_attr_v2i_t,
    pub max: exr_attr_v2i_t,
}
#[test]
fn bindgen_test_layout_exr_attr_box2i_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_box2i_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_box2i_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_box2i_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_box2i_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_box2i_t>())).min as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_box2i_t),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_box2i_t>())).max as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_box2i_t),
            "::",
            stringify!(max)
        )
    );
}
#[doc = " @brief struct to hold a floating-point box / region definition"]
#[repr(C)]
pub struct exr_attr_box2f_t {
    pub min: exr_attr_v2f_t,
    pub max: exr_attr_v2f_t,
}
#[test]
fn bindgen_test_layout_exr_attr_box2f_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_box2f_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_box2f_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_box2f_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_box2f_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_box2f_t>())).min as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_box2f_t),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_box2f_t>())).max as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_box2f_t),
            "::",
            stringify!(max)
        )
    );
}
#[doc = " @brief Struct holding base tiledesc attribute type defined in spec"]
#[doc = ""]
#[doc = " NB: this is in a tightly packed area so it can be read directly, be"]
#[doc = " careful it doesn't become padded to the next uint32_t boundary"]
#[repr(C, packed)]
pub struct exr_attr_tiledesc_t {
    pub x_size: u32,
    pub y_size: u32,
    pub level_and_round: u8,
}
#[test]
fn bindgen_test_layout_exr_attr_tiledesc_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_tiledesc_t>(),
        9usize,
        concat!("Size of: ", stringify!(exr_attr_tiledesc_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_tiledesc_t>(),
        1usize,
        concat!("Alignment of ", stringify!(exr_attr_tiledesc_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_tiledesc_t>())).x_size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_tiledesc_t),
            "::",
            stringify!(x_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_tiledesc_t>())).y_size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_tiledesc_t),
            "::",
            stringify!(y_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_tiledesc_t>())).level_and_round
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_tiledesc_t),
            "::",
            stringify!(level_and_round)
        )
    );
}
#[doc = " Storage for a string"]
#[repr(C)]
pub struct exr_attr_string_t {
    pub length: i32,
    #[doc = " if this is non-zero, the string owns the data, if 0, is a const ref to a static string"]
    pub alloc_size: i32,
    pub str_: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_exr_attr_string_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_string_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_string_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_string_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_string_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_string_t>())).length as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_string_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_string_t>())).alloc_size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_string_t),
            "::",
            stringify!(alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_string_t>())).str_ as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_string_t),
            "::",
            stringify!(str_)
        )
    );
}
#[doc = " storage for a string vector"]
#[repr(C)]
pub struct exr_attr_string_vector_t {
    pub n_strings: i32,
    #[doc = " if this is non-zero, the string vector owns the data, if 0, is a const ref"]
    pub alloc_size: i32,
    pub strings: *const exr_attr_string_t,
}
#[test]
fn bindgen_test_layout_exr_attr_string_vector_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_string_vector_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_string_vector_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_string_vector_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_string_vector_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_string_vector_t>())).n_strings
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_string_vector_t),
            "::",
            stringify!(n_strings)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_string_vector_t>())).alloc_size
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_string_vector_t),
            "::",
            stringify!(alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_string_vector_t>())).strings
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_string_vector_t),
            "::",
            stringify!(strings)
        )
    );
}
#[doc = " float vector storage struct"]
#[repr(C)]
pub struct exr_attr_float_vector_t {
    pub length: i32,
    #[doc = " if this is non-zero, the float vector owns the data, if 0, is a const ref"]
    pub alloc_size: i32,
    pub arr: *const f32,
}
#[test]
fn bindgen_test_layout_exr_attr_float_vector_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_float_vector_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_float_vector_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_float_vector_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_float_vector_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_float_vector_t>())).length
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_float_vector_t),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_float_vector_t>())).alloc_size
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_float_vector_t),
            "::",
            stringify!(alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_float_vector_t>())).arr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_float_vector_t),
            "::",
            stringify!(arr)
        )
    );
}
pub const exr_perceptual_treatment_t_EXR_PERCEPTUALLY_LOGARITHMIC:
    exr_perceptual_treatment_t = 0;
pub const exr_perceptual_treatment_t_EXR_PERCEPTUALLY_LINEAR:
    exr_perceptual_treatment_t = 1;
#[doc = " Hint for lossy compression methods about how to treat values"]
#[doc = " (logarithmic or linear), meaning a human sees values like R, G, B,"]
#[doc = " luminance difference between 0.1 and 0.2 as about the same as 1.0"]
#[doc = " to 2.0 (logarithmic), where chroma coordinates are closer to linear"]
#[doc = " (0.1 and 0.2 is about the same difference as 1.0 and 1.1)"]
pub type exr_perceptual_treatment_t = ::std::os::raw::c_uint;
#[doc = " Individual channel information"]
#[repr(C)]
pub struct exr_attr_chlist_entry_t {
    pub name: exr_attr_string_t,
    #[doc = " Data representation for these pixels: uint, half, float"]
    pub pixel_type: exr_pixel_type_t,
    #[doc = " Possible values are 0 and 1 per docs \\ref exr_perceptual_treatment_t"]
    pub p_linear: u8,
    pub reserved: [u8; 3usize],
    pub x_sampling: i32,
    pub y_sampling: i32,
}
#[test]
fn bindgen_test_layout_exr_attr_chlist_entry_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_chlist_entry_t>(),
        32usize,
        concat!("Size of: ", stringify!(exr_attr_chlist_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_chlist_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_chlist_entry_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chlist_entry_t>())).name as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_entry_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chlist_entry_t>())).pixel_type
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_entry_t),
            "::",
            stringify!(pixel_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chlist_entry_t>())).p_linear
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_entry_t),
            "::",
            stringify!(p_linear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chlist_entry_t>())).reserved
                as *const _ as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_entry_t),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chlist_entry_t>())).x_sampling
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_entry_t),
            "::",
            stringify!(x_sampling)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chlist_entry_t>())).y_sampling
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_entry_t),
            "::",
            stringify!(y_sampling)
        )
    );
}
#[doc = " List of channel information (sorted alphabetically)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exr_attr_chlist_t {
    pub num_channels: ::std::os::raw::c_int,
    pub num_alloced: ::std::os::raw::c_int,
    pub entries: *const exr_attr_chlist_entry_t,
}
#[test]
fn bindgen_test_layout_exr_attr_chlist_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_chlist_t>(),
        16usize,
        concat!("Size of: ", stringify!(exr_attr_chlist_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_chlist_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_chlist_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chlist_t>())).num_channels
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_t),
            "::",
            stringify!(num_channels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chlist_t>())).num_alloced
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_t),
            "::",
            stringify!(num_alloced)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_chlist_t>())).entries as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_chlist_t),
            "::",
            stringify!(entries)
        )
    );
}
#[doc = " @brief Struct to define attributes of an embedded preview image"]
#[repr(C)]
pub struct exr_attr_preview_t {
    pub width: u32,
    pub height: u32,
    #[doc = " if this is non-zero, the preview owns the data, if 0, is a const ref"]
    pub alloc_size: size_t,
    pub rgba: *const u8,
}
#[test]
fn bindgen_test_layout_exr_attr_preview_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_preview_t>(),
        24usize,
        concat!("Size of: ", stringify!(exr_attr_preview_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_preview_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_preview_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_preview_t>())).width as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_preview_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_preview_t>())).height as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_preview_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_preview_t>())).alloc_size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_preview_t),
            "::",
            stringify!(alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_preview_t>())).rgba as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_preview_t),
            "::",
            stringify!(rgba)
        )
    );
}
#[doc = " Custom storage structure for opaque data"]
#[doc = ""]
#[doc = " Handlers for opaque types can be registered, then when a"]
#[doc = " non-builtin type is encountered with a registered handler, the"]
#[doc = " function pointers to unpack / pack it will be set up."]
#[doc = ""]
#[doc = " @sa exr_register_attr_type_handler"]
#[repr(C)]
pub struct exr_attr_opaquedata_t {
    pub size: i32,
    pub unpacked_size: i32,
    #[doc = " if this is non-zero, the struct owns the data, if 0, is a const ref"]
    pub packed_alloc_size: i32,
    pub pad: [u8; 4usize],
    pub packed_data: *mut ::std::os::raw::c_void,
    #[doc = " when an application wants to have custom data, they can store an unpacked form here which will"]
    #[doc = " be requested to be destroyed upon destruction of the attribute"]
    pub unpacked_data: *mut ::std::os::raw::c_void,
    pub unpack_func_ptr: ::std::option::Option<
        unsafe extern "C" fn(
            ctxt: exr_context_t,
            data: *const ::std::os::raw::c_void,
            attrsize: i32,
            outsize: *mut i32,
            outbuffer: *mut *mut ::std::os::raw::c_void,
        ) -> exr_result_t,
    >,
    pub pack_func_ptr: ::std::option::Option<
        unsafe extern "C" fn(
            ctxt: exr_context_t,
            data: *const ::std::os::raw::c_void,
            datasize: i32,
            outsize: *mut i32,
            outbuffer: *mut ::std::os::raw::c_void,
        ) -> exr_result_t,
    >,
    pub destroy_unpacked_func_ptr: ::std::option::Option<
        unsafe extern "C" fn(
            ctxt: exr_context_t,
            data: *mut ::std::os::raw::c_void,
            attrsize: i32,
        ),
    >,
}
#[test]
fn bindgen_test_layout_exr_attr_opaquedata_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attr_opaquedata_t>(),
        56usize,
        concat!("Size of: ", stringify!(exr_attr_opaquedata_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attr_opaquedata_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attr_opaquedata_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_opaquedata_t>())).size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_opaquedata_t>())).unpacked_size
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(unpacked_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_opaquedata_t>())).packed_alloc_size
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(packed_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_opaquedata_t>())).pad as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_opaquedata_t>())).packed_data
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(packed_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_opaquedata_t>())).unpacked_data
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(unpacked_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_opaquedata_t>())).unpack_func_ptr
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(unpack_func_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_opaquedata_t>())).pack_func_ptr
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(pack_func_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attr_opaquedata_t>()))
                .destroy_unpacked_func_ptr as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attr_opaquedata_t),
            "::",
            stringify!(destroy_unpacked_func_ptr)
        )
    );
}
pub const exr_attribute_type_t_EXR_ATTR_UNKNOWN: exr_attribute_type_t = 0;
#[doc = "< integer region definition. @see exr_box2i"]
pub const exr_attribute_type_t_EXR_ATTR_BOX2I: exr_attribute_type_t = 1;
#[doc = "< float region definition. @see exr_box2f"]
pub const exr_attribute_type_t_EXR_ATTR_BOX2F: exr_attribute_type_t = 2;
#[doc = "< Definition of channels in file @see exr_chlist_entry"]
pub const exr_attribute_type_t_EXR_ATTR_CHLIST: exr_attribute_type_t = 3;
#[doc = "< Values to specify color space of colors in file @see exr_attr_chromaticities_t"]
pub const exr_attribute_type_t_EXR_ATTR_CHROMATICITIES: exr_attribute_type_t =
    4;
#[doc = "< uint8_t declaring compression present"]
pub const exr_attribute_type_t_EXR_ATTR_COMPRESSION: exr_attribute_type_t = 5;
#[doc = "< double precision floating point number"]
pub const exr_attribute_type_t_EXR_ATTR_DOUBLE: exr_attribute_type_t = 6;
#[doc = "< uint8_t declaring environment map type"]
pub const exr_attribute_type_t_EXR_ATTR_ENVMAP: exr_attribute_type_t = 7;
#[doc = "< a normal (4 byte) precision floating point number"]
pub const exr_attribute_type_t_EXR_ATTR_FLOAT: exr_attribute_type_t = 8;
#[doc = "< a list of normal (4 byte) precision floating point numbers"]
pub const exr_attribute_type_t_EXR_ATTR_FLOAT_VECTOR: exr_attribute_type_t = 9;
#[doc = "< a 32-bit signed integer value"]
pub const exr_attribute_type_t_EXR_ATTR_INT: exr_attribute_type_t = 10;
#[doc = "< structure recording keycode @see exr_attr_keycode_t"]
pub const exr_attribute_type_t_EXR_ATTR_KEYCODE: exr_attribute_type_t = 11;
#[doc = "< uint8_t declaring scanline ordering"]
pub const exr_attribute_type_t_EXR_ATTR_LINEORDER: exr_attribute_type_t = 12;
#[doc = "< 9 32-bit floats representing a 3x3 matrix"]
pub const exr_attribute_type_t_EXR_ATTR_M33F: exr_attribute_type_t = 13;
#[doc = "< 9 64-bit floats representing a 3x3 matrix"]
pub const exr_attribute_type_t_EXR_ATTR_M33D: exr_attribute_type_t = 14;
#[doc = "< 16 32-bit floats representing a 4x4 matrix"]
pub const exr_attribute_type_t_EXR_ATTR_M44F: exr_attribute_type_t = 15;
#[doc = "< 16 64-bit floats representing a 4x4 matrix"]
pub const exr_attribute_type_t_EXR_ATTR_M44D: exr_attribute_type_t = 16;
#[doc = "< 2 unsigned ints followed by 4 x w x h uint8_t image"]
pub const exr_attribute_type_t_EXR_ATTR_PREVIEW: exr_attribute_type_t = 17;
#[doc = "< int followed by unsigned int"]
pub const exr_attribute_type_t_EXR_ATTR_RATIONAL: exr_attribute_type_t = 18;
#[doc = "< int (length) followed by char string data"]
pub const exr_attribute_type_t_EXR_ATTR_STRING: exr_attribute_type_t = 19;
#[doc = "< 0 or more text strings (int + string). number is based on attribute size"]
pub const exr_attribute_type_t_EXR_ATTR_STRING_VECTOR: exr_attribute_type_t =
    20;
#[doc = "< 2 unsigned ints xSize, ySize followed by mode"]
pub const exr_attribute_type_t_EXR_ATTR_TILEDESC: exr_attribute_type_t = 21;
#[doc = "< 2 unsigned ints time and flags, user data"]
pub const exr_attribute_type_t_EXR_ATTR_TIMECODE: exr_attribute_type_t = 22;
#[doc = "< pair of 32-bit integers"]
pub const exr_attribute_type_t_EXR_ATTR_V2I: exr_attribute_type_t = 23;
#[doc = "< pair of 32-bit floats"]
pub const exr_attribute_type_t_EXR_ATTR_V2F: exr_attribute_type_t = 24;
#[doc = "< pair of 64-bit floats"]
pub const exr_attribute_type_t_EXR_ATTR_V2D: exr_attribute_type_t = 25;
#[doc = "< set of 3 32-bit integers"]
pub const exr_attribute_type_t_EXR_ATTR_V3I: exr_attribute_type_t = 26;
#[doc = "< set of 3 32-bit floats"]
pub const exr_attribute_type_t_EXR_ATTR_V3F: exr_attribute_type_t = 27;
#[doc = "< set of 3 64-bit floats"]
pub const exr_attribute_type_t_EXR_ATTR_V3D: exr_attribute_type_t = 28;
#[doc = "< user / unknown provided type"]
pub const exr_attribute_type_t_EXR_ATTR_OPAQUE: exr_attribute_type_t = 29;
pub const exr_attribute_type_t_EXR_ATTR_LAST_KNOWN_TYPE: exr_attribute_type_t =
    30;
#[doc = " @brief built-in / native attribute type enum"]
#[doc = ""]
#[doc = " This will enable us to do a tagged type struct to generically store"]
#[doc = " attributes."]
pub type exr_attribute_type_t = ::std::os::raw::c_uint;
#[doc = " @brief storage, name and type information for an attribute."]
#[doc = ""]
#[doc = " Attributes (metadata) for the file cause a surprising amount of"]
#[doc = " overhead. It is not uncommon for a production-grade EXR to have"]
#[doc = " many attributes. As such, the attribute struct is designed in a"]
#[doc = " slightly more complicated manner. It is optimized to have the"]
#[doc = " storage for that attribute: the struct itself, the name, the type,"]
#[doc = " and the data all allocated as one block. Further, the type and"]
#[doc = " standard names may use a static string to avoid allocating space"]
#[doc = " for those as necessary with the pointers pointing to static strings"]
#[doc = " (not to be freed). Finally, small values are optimized for."]
#[repr(C)]
pub struct exr_attribute_t {
    #[doc = " name of the attribute"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " string type name of the attribute"]
    pub type_name: *const ::std::os::raw::c_char,
    #[doc = " length of name string (short flag is 31 max, long allows 255)"]
    pub name_length: u8,
    #[doc = " length of type string (short flag is 31 max, long allows 255)"]
    pub type_name_length: u8,
    pub pad: [u8; 2usize],
    #[doc = " enum of the attribute type"]
    pub type_: exr_attribute_type_t,
    pub __bindgen_anon_1: exr_attribute_t__bindgen_ty_1,
}
#[doc = " Union of pointers of different types that can be used to type"]
#[doc = " pun to an appropriate type for builtins. Do note that while"]
#[doc = " this looks like a big thing, it is only the size of a single"]
#[doc = " pointer.  these are all pointers into some other data block"]
#[doc = " storing the value you want, with the exception of the pod types"]
#[doc = " which are just put in place (i.e. small value optimization)"]
#[doc = ""]
#[doc = " The attribute type \\ref type should directly correlate to one of"]
#[doc = " these entries"]
#[repr(C)]
pub struct exr_attribute_t__bindgen_ty_1 {
    pub uc: __BindgenUnionField<u8>,
    pub d: __BindgenUnionField<f64>,
    pub f: __BindgenUnionField<f32>,
    pub i: __BindgenUnionField<i32>,
    pub box2i: __BindgenUnionField<*mut exr_attr_box2i_t>,
    pub box2f: __BindgenUnionField<*mut exr_attr_box2f_t>,
    pub chlist: __BindgenUnionField<*mut exr_attr_chlist_t>,
    pub chromaticities: __BindgenUnionField<*mut exr_attr_chromaticities_t>,
    pub keycode: __BindgenUnionField<*mut exr_attr_keycode_t>,
    pub floatvector: __BindgenUnionField<*mut exr_attr_float_vector_t>,
    pub m33f: __BindgenUnionField<*mut exr_attr_m33f_t>,
    pub m33d: __BindgenUnionField<*mut exr_attr_m33d_t>,
    pub m44f: __BindgenUnionField<*mut exr_attr_m44f_t>,
    pub m44d: __BindgenUnionField<*mut exr_attr_m44d_t>,
    pub preview: __BindgenUnionField<*mut exr_attr_preview_t>,
    pub rational: __BindgenUnionField<*mut exr_attr_rational_t>,
    pub string: __BindgenUnionField<*mut exr_attr_string_t>,
    pub stringvector: __BindgenUnionField<*mut exr_attr_string_vector_t>,
    pub tiledesc: __BindgenUnionField<*mut exr_attr_tiledesc_t>,
    pub timecode: __BindgenUnionField<*mut exr_attr_timecode_t>,
    pub v2i: __BindgenUnionField<*mut exr_attr_v2i_t>,
    pub v2f: __BindgenUnionField<*mut exr_attr_v2f_t>,
    pub v2d: __BindgenUnionField<*mut exr_attr_v2d_t>,
    pub v3i: __BindgenUnionField<*mut exr_attr_v3i_t>,
    pub v3f: __BindgenUnionField<*mut exr_attr_v3f_t>,
    pub v3d: __BindgenUnionField<*mut exr_attr_v3d_t>,
    pub opaque: __BindgenUnionField<*mut exr_attr_opaquedata_t>,
    pub rawptr: __BindgenUnionField<*mut u8>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_exr_attribute_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_attribute_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(exr_attribute_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attribute_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attribute_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).uc
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(uc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).d
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).f
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).i
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).box2i
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(box2i)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).box2f
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(box2f)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).chlist
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(chlist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>()))
                .chromaticities as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(chromaticities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).keycode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(keycode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>()))
                .floatvector as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(floatvector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).m33f
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(m33f)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).m33d
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(m33d)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).m44f
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(m44f)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).m44d
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(m44d)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).preview
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(preview)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).rational
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(rational)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).string
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>()))
                .stringvector as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(stringvector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).tiledesc
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(tiledesc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).timecode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(timecode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).v2i
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(v2i)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).v2f
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(v2f)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).v2d
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(v2d)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).v3i
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(v3i)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).v3f
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(v3f)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).v3d
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(v3d)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).opaque
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t__bindgen_ty_1>())).rawptr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t__bindgen_ty_1),
            "::",
            stringify!(rawptr)
        )
    );
}
#[test]
fn bindgen_test_layout_exr_attribute_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_attribute_t>(),
        32usize,
        concat!("Size of: ", stringify!(exr_attribute_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_attribute_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_attribute_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t>())).name as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t>())).type_name as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t>())).name_length as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t),
            "::",
            stringify!(name_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t>())).type_name_length
                as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t),
            "::",
            stringify!(type_name_length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t>())).pad as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_attribute_t>())).type_ as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_attribute_t),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    #[doc = " @brief Query how many parts are in the file"]
    pub fn exr_get_count(
        ctxt: exr_const_context_t,
        count: *mut ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query the part name for the specified part"]
    #[doc = ""]
    #[doc = " NB: If this file is a single part file and name has not been set, this"]
    #[doc = " will return NULL."]
    pub fn exr_get_name(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query the storage type for the specified part"]
    pub fn exr_get_storage(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut exr_storage_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Define a new part in the file"]
    pub fn exr_add_part(
        ctxt: exr_context_t,
        partname: *const ::std::os::raw::c_char,
        type_: exr_storage_t,
        new_index: *mut ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query how many levels are in the specified part."]
    #[doc = ""]
    #[doc = " If the part is a tiled part, fill in how many tile levels are present."]
    #[doc = ""]
    #[doc = " Return `ERR_SUCCESS` on success, an error otherwise (i.e. if the part"]
    #[doc = " is not tiled)."]
    #[doc = ""]
    #[doc = " It is valid to pass NULL to either of the @p levelsx or @p levelsy"]
    #[doc = " arguments, which enables testing if this part is a tiled part, or"]
    #[doc = " if you don't need both (i.e. in the case of a mip-level tiled"]
    #[doc = " image)"]
    pub fn exr_get_tile_levels(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        levelsx: *mut i32,
        levelsy: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query the tile size for a particular level in the specified part"]
    #[doc = ""]
    #[doc = " If the part is a tiled part, fill in the tile size for the"]
    #[doc = " specified part / level."]
    #[doc = ""]
    #[doc = " Return `ERR_SUCCESS` on `success`, an error otherwise (i.e. if the"]
    #[doc = " part is not tiled)."]
    #[doc = ""]
    #[doc = " It is valid to pass NULL to either of the @p tilew or @p tileh"]
    #[doc = " arguments, which enables testing if this part is a tiled part, or"]
    #[doc = " if you don't need both (i.e. in the case of a mip-level tiled"]
    #[doc = " image)"]
    pub fn exr_get_tile_sizes(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        tilew: *mut i32,
        tileh: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query the data sizes for a particular level in the specified part"]
    #[doc = ""]
    #[doc = " If the part is a tiled part, fill in the width / height for the"]
    #[doc = " specified levels."]
    #[doc = ""]
    #[doc = " Return `ERR_SUCCESS` on success, an error otherwise (i.e. if the part"]
    #[doc = " is not tiled)"]
    #[doc = ""]
    #[doc = " It is valid to pass NULL to either of the @p levw or @p levh"]
    #[doc = " arguments, which enables testing if this part is a tiled part, or"]
    #[doc = " if you don't need both for some reason"]
    pub fn exr_get_level_sizes(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        levw: *mut i32,
        levh: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Return the number of chunks contained in this part of the file"]
    #[doc = ""]
    #[doc = " As in the technical documentation for OpenEXR, the chunk is the"]
    #[doc = " generic term for a pixel data block. This is the atomic unit that"]
    #[doc = " this library uses to negotiate data to and from a context."]
    #[doc = ""]
    #[doc = " This should be used as a basis for splitting up how a file is"]
    #[doc = " processed. Depending on the compression, a different number of"]
    #[doc = " scanlines are encoded in each chunk, and since those need to be"]
    #[doc = " encoded / decoded as a block, the chunk should be the basis for I/O"]
    #[doc = " as well."]
    pub fn exr_get_chunk_count(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Return the number of scanlines chunks for this file part"]
    #[doc = ""]
    #[doc = " When iterating over a scanline file, this may be an easier metric"]
    #[doc = " for multi-threading or other access than only negotiating chunk"]
    #[doc = " counts, and so is provided as a utility."]
    pub fn exr_get_scanlines_per_chunk(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Return the maximum unpacked size of a chunk for the file part"]
    #[doc = ""]
    #[doc = " This may be used ahead of any actual reading of data, so can be"]
    #[doc = " used to pre-allocate buffers for multiple threads in one block or"]
    #[doc = " whatever your application may require."]
    pub fn exr_get_chunk_unpacked_size(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut u64,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query the count of attributes in a part"]
    pub fn exr_get_attribute_count(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        count: *mut i32,
    ) -> exr_result_t;
}
impl exr_attr_list_access_mode {
    #[doc = "< order they appear in the file"]
    pub const EXR_ATTR_LIST_FILE_ORDER: exr_attr_list_access_mode =
        exr_attr_list_access_mode(0);
}
impl exr_attr_list_access_mode {
    #[doc = "< alphabetically sorted"]
    pub const EXR_ATTR_LIST_SORTED_ORDER: exr_attr_list_access_mode =
        exr_attr_list_access_mode(1);
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct exr_attr_list_access_mode(pub ::std::os::raw::c_uint);
extern "C" {
    #[doc = " @brief Query a particular attribute by index"]
    pub fn exr_get_attribute_by_index(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        mode: exr_attr_list_access_mode,
        idx: i32,
        outattr: *mut *const exr_attribute_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query a particular attribute by name"]
    pub fn exr_get_attribute_by_name(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        outattr: *mut *const exr_attribute_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Query the list of attributes in a part"]
    #[doc = ""]
    #[doc = " This retrieves a list of attributes currently defined in a part."]
    #[doc = ""]
    #[doc = " If outlist is NULL, this function still succeeds, filling only the"]
    #[doc = " count. In this manner, the user can allocate memory for the list of"]
    #[doc = " attributes, then re-call this function to get the full list."]
    pub fn exr_get_attribute_list(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        mode: exr_attr_list_access_mode,
        count: *mut i32,
        outlist: *mut *const exr_attribute_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Declare an attribute within the specified part"]
    #[doc = ""]
    #[doc = " Only valid when a file is opened for write."]
    pub fn exr_attr_declare_by_type(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        newattr: *mut *mut exr_attribute_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Declare an attribute within the specified part"]
    #[doc = ""]
    #[doc = " Only valid when a file is opened for write."]
    pub fn exr_attr_declare(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        type_: exr_attribute_type_t,
        newattr: *mut *mut exr_attribute_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Initialize all required attributes for all files"]
    #[doc = ""]
    #[doc = " NB: other file types do require other attributes, such as the tile"]
    #[doc = " description for a tiled file."]
    pub fn exr_initialize_required_attr(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        displayWindow: *const exr_attr_box2i_t,
        dataWindow: *const exr_attr_box2i_t,
        pixelaspectratio: f32,
        screenWindowCenter: *const exr_attr_v2f_t,
        screenWindowWidth: f32,
        lineorder: exr_lineorder_t,
        ctype: exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Initialize all required attributes to default values:"]
    #[doc = ""]
    #[doc = " - `displayWindow` is set to (0, 0 -> @p width - 1, @p height - 1)"]
    #[doc = " - `dataWindow` is set to (0, 0 -> @p width - 1, @p height - 1)"]
    #[doc = " - `pixelAspectRatio` is set to 1.0"]
    #[doc = " - `screenWindowCenter` is set to 0.f, 0.f"]
    #[doc = " - `screenWindowWidth` is set to 1.f"]
    #[doc = " - `lineorder` is set to `INCREASING_Y`"]
    #[doc = " - `compression` is set to @p ctype"]
    pub fn exr_initialize_required_attr_simple(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        width: i32,
        height: i32,
        ctype: exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Copy the attributes from one part to another"]
    #[doc = ""]
    #[doc = " This allows one to quickly unassigned attributes from one source to another."]
    #[doc = ""]
    #[doc = " If an attribute in the source part has not been yet set in the"]
    #[doc = " destination part, the item will be copied over."]
    #[doc = ""]
    #[doc = " For example, when you add a part, the storage type and name"]
    #[doc = " attributes are required arguments to the definition of a new part,"]
    #[doc = " but channels has not yet been assigned. So by calling this with an"]
    #[doc = " input file as the source, you can copy the channel definitions (and"]
    #[doc = " any other unassigned attributes from the source)."]
    pub fn exr_copy_unset_attributes(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        source: exr_const_context_t,
        src_part_index: ::std::os::raw::c_int,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the list of channels"]
    pub fn exr_get_channels(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        chlist: *mut *const exr_attr_chlist_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Define a new channel to the output file part"]
    #[doc = ""]
    #[doc = " The @p percept parameter is used for lossy compression techniques"]
    #[doc = " to indicate that the value represented is closer to linear (1) or"]
    #[doc = " closer to logarithmic (0). For r, g, b, luminance, this is normally"]
    #[doc = " 0"]
    pub fn exr_add_channel(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        ptype: exr_pixel_type_t,
        percept: exr_perceptual_treatment_t,
        xsamp: i32,
        ysamp: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Copy the channels from another source"]
    #[doc = ""]
    #[doc = " Useful if you are manually constructing the list or simply copying"]
    #[doc = " from an input file"]
    pub fn exr_set_channels(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        channels: *const exr_attr_chlist_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the compression method used for the specified part"]
    pub fn exr_get_compression(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        compression: *mut exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the compression method used for the specified part"]
    pub fn exr_set_compression(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        ctype: exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the data window for the specified part"]
    pub fn exr_get_data_window(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut exr_attr_box2i_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the data window for the specified part"]
    pub fn exr_set_data_window(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        dw: *const exr_attr_box2i_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve the display window for the specified part"]
    pub fn exr_get_display_window(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut exr_attr_box2i_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the display window for the specified part"]
    pub fn exr_set_display_window(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        dw: *const exr_attr_box2i_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve the line order for storing data in the specified part (use 0 for single part images)"]
    pub fn exr_get_lineorder(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut exr_lineorder_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the line order for storing data in the specified part (use 0 for single part images)"]
    pub fn exr_set_lineorder(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        lo: exr_lineorder_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the pixel aspect ratio for the specified part (use 0 for single part images)."]
    pub fn exr_get_pixel_aspect_ratio(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        par: *mut f32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the pixel aspect ratio for the specified part (use 0 for single part images)"]
    pub fn exr_set_pixel_aspect_ratio(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        par: f32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the screen oriented window center for the specified part (use 0 for single part images)"]
    pub fn exr_get_screen_window_center(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        wc: *mut exr_attr_v2f_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the screen oriented window center for the specified part (use 0 for single part images)"]
    pub fn exr_set_screen_window_center(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        wc: *const exr_attr_v2f_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve the screen oriented window width for the specified part (use 0 for single part images)"]
    pub fn exr_get_screen_window_width(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut f32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the screen oriented window width for the specified part (use 0 for single part images)"]
    pub fn exr_set_screen_window_width(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        ssw: f32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Retrieve the tiling info for a tiled part (use 0 for single part images)"]
    pub fn exr_get_tile_descriptor(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        xsize: *mut u32,
        ysize: *mut u32,
        level: *mut exr_tile_level_mode_t,
        round: *mut exr_tile_round_mode_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Set the tiling info for a tiled part (use 0 for single part images)"]
    pub fn exr_set_tile_descriptor(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        x_size: u32,
        y_size: u32,
        level_mode: exr_tile_level_mode_t,
        round_mode: exr_tile_round_mode_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_name(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        val: *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_get_version(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        out: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_version(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        val: i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_set_chunk_count(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        val: i32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @defgroup BuiltinAttributeHelpers Attribute utilities for builtin types"]
    #[doc = ""]
    #[doc = " @brief These are a group of functions for attributes that use the builtin types."]
    #[doc = ""]
    #[doc = " @{"]
    pub fn exr_attr_get_box2i(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        outval: *mut exr_attr_box2i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_box2i(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: *const exr_attr_box2i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_box2f(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        outval: *mut exr_attr_box2f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_box2f(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: *const exr_attr_box2f_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Zero-copy query of channel data"]
    #[doc = ""]
    #[doc = " Do not free or manipulate the @p chlist data, or use"]
    #[doc = " after the lifetime of the context."]
    pub fn exr_attr_get_channels(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        chlist: *mut *const exr_attr_chlist_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief This allows one to quickly copy the channels from one file"]
    #[doc = " to another"]
    pub fn exr_attr_set_channels(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        channels: *const exr_attr_chlist_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_chromaticities(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        chroma: *mut exr_attr_chromaticities_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_chromaticities(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        chroma: *const exr_attr_chromaticities_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_compression(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_compression(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        comp: exr_compression_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_double(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut f64,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_double(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: f64,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_envmap(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_envmap_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_envmap(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        emap: exr_envmap_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_float(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut f32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_float(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: f32,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Zero-copy query of float data"]
    #[doc = ""]
    #[doc = " Do not free or manipulate the @p out data, or use after the"]
    #[doc = " lifetime of the context."]
    pub fn exr_attr_get_float_vector(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        sz: *mut i32,
        out: *mut *const f32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_float_vector(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        sz: i32,
        vals: *const f32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_int(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_int(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        val: i32,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_keycode(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_keycode_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_keycode(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        kc: *const exr_attr_keycode_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_lineorder(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_lineorder_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_lineorder(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        lo: exr_lineorder_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_m33f(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_m33f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_m33f(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        m: *const exr_attr_m33f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_m33d(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_m33d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_m33d(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        m: *const exr_attr_m33d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_m44f(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_m44f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_m44f(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        m: *const exr_attr_m44f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_m44d(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_m44d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_m44d(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        m: *const exr_attr_m44d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_preview(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_preview_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_preview(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        p: *const exr_attr_preview_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_rational(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_rational_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_rational(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        r: *const exr_attr_rational_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Zero-copy query of string value"]
    #[doc = ""]
    #[doc = " Do not modify the string pointed to by @p out, and do not use"]
    #[doc = " after the lifetime of the context."]
    pub fn exr_attr_get_string(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        length: *mut i32,
        out: *mut *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_string(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        s: *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @brief Zero-copy query of string data"]
    #[doc = ""]
    #[doc = " Do not free the strings pointed to by the array."]
    #[doc = ""]
    #[doc = " Must provide @p size."]
    #[doc = ""]
    #[doc = " @param out must be a ``const char**`` array large enough to hold"]
    #[doc = " the string pointers for the string vector when provided."]
    pub fn exr_attr_get_string_vector(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        size: *mut i32,
        out: *mut *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_string_vector(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        size: i32,
        sv: *mut *const ::std::os::raw::c_char,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_tiledesc(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_tiledesc_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_tiledesc(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        td: *const exr_attr_tiledesc_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_timecode(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_timecode_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_timecode(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        tc: *const exr_attr_timecode_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v2i(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v2i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v2i(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v2i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v2f(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v2f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v2f(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v2f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v2d(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v2d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v2d(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v2d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v3i(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v3i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v3i(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v3i_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v3f(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v3f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v3f(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v3f_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_v3d(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        out: *mut exr_attr_v3d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_v3d(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        v: *const exr_attr_v3d_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_get_user(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        type_: *mut *const ::std::os::raw::c_char,
        size: *mut i32,
        out: *mut *const ::std::os::raw::c_void,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_attr_set_user(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        size: i32,
        out: *const ::std::os::raw::c_void,
    ) -> exr_result_t;
}
#[doc = " Structure describing raw data information about a chunk."]
#[doc = ""]
#[doc = " A chunk is the generic term for a pixel data block in an EXR file,"]
#[doc = " as described in the OpenEXR File Layout documentation. This is"]
#[doc = " common between all different forms of data that can be stored."]
#[repr(C)]
pub struct exr_chunk_info_t {
    pub idx: i32,
    #[doc = " for tiles, this is the tilex; for scans it is the x"]
    pub start_x: i32,
    #[doc = " for tiles, this is the tiley; for scans it is the scanline y"]
    pub start_y: i32,
    #[doc = "< for this chunk"]
    pub height: i32,
    #[doc = "< for this chunk"]
    pub width: i32,
    #[doc = "< for tiled files"]
    pub level_x: u8,
    #[doc = "< for tiled files"]
    pub level_y: u8,
    pub type_: u8,
    pub compression: u8,
    pub data_offset: u64,
    pub packed_size: u64,
    pub unpacked_size: u64,
    pub sample_count_data_offset: u64,
    pub sample_count_table_size: u64,
}
#[test]
fn bindgen_test_layout_exr_chunk_info_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_chunk_info_t>(),
        64usize,
        concat!("Size of: ", stringify!(exr_chunk_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_chunk_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_chunk_info_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_chunk_info_t>())).idx as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_chunk_info_t>())).start_x as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(start_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_chunk_info_t>())).start_y as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(start_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_chunk_info_t>())).height as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_chunk_info_t>())).width as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_chunk_info_t>())).level_x as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(level_x)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_chunk_info_t>())).level_y as *const _
                as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(level_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_chunk_info_t>())).type_ as *const _
                as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_chunk_info_t>())).compression as *const _
                as usize
        },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(compression)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_chunk_info_t>())).data_offset as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(data_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_chunk_info_t>())).packed_size as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(packed_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_chunk_info_t>())).unpacked_size
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(unpacked_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_chunk_info_t>()))
                .sample_count_data_offset as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(sample_count_data_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_chunk_info_t>())).sample_count_table_size
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_chunk_info_t),
            "::",
            stringify!(sample_count_table_size)
        )
    );
}
extern "C" {
    pub fn exr_read_scanline_chunk_info(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        cinfo: *mut exr_chunk_info_t,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_read_tile_chunk_info(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        tilex: ::std::os::raw::c_int,
        tiley: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        cinfo: *mut exr_chunk_info_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Read the packed data block for a chunk"]
    #[doc = ""]
    #[doc = " This assumes that the buffer pointed to by @p packed_data is"]
    #[doc = " large enough to hold the chunk block info packed_size bytes"]
    pub fn exr_read_chunk(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        packed_data: *mut ::std::os::raw::c_void,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Read chunk for deep data."]
    #[doc = ""]
    #[doc = " This allows one to read the packed data, the sample count data, or both."]
    #[doc = " \\ref exr_read_chunk also works to read deep data packed data,"]
    #[doc = " but this is a routine to get the sample count table and the packed"]
    #[doc = " data in one go, or if you want to pre-read the sample count data,"]
    #[doc = " you can get just that buffer."]
    pub fn exr_read_deep_chunk(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        packed_data: *mut ::std::os::raw::c_void,
        sample_data: *mut ::std::os::raw::c_void,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Initialize a \\ref exr_chunk_info_t structure when encoding scanline"]
    #[doc = " data (similar to read but does not do anything with a chunk"]
    #[doc = " table)"]
    pub fn exr_write_scanline_chunk_info(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        cinfo: *mut exr_chunk_info_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Initialize a \\ref chunk_info_t structure when encoding tiled data"]
    #[doc = " (similar to read but does not do anything with a chunk table)"]
    pub fn exr_write_tile_chunk_info(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        tilex: ::std::os::raw::c_int,
        tiley: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        cinfo: *mut exr_chunk_info_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @p y must the appropriate starting y for the specified chunk"]
    pub fn exr_write_scanline_chunk(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        packed_data: *const ::std::os::raw::c_void,
        packed_size: u64,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " @p y must the appropriate starting y for the specified chunk"]
    pub fn exr_write_deep_scanline_chunk(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        packed_data: *const ::std::os::raw::c_void,
        packed_size: u64,
        unpacked_size: u64,
        sample_data: *const ::std::os::raw::c_void,
        sample_data_size: u64,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_write_tile_chunk(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        tilex: ::std::os::raw::c_int,
        tiley: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        packed_data: *const ::std::os::raw::c_void,
        packed_size: u64,
    ) -> exr_result_t;
}
extern "C" {
    pub fn exr_write_deep_tile_chunk(
        ctxt: exr_context_t,
        part_index: ::std::os::raw::c_int,
        tilex: ::std::os::raw::c_int,
        tiley: ::std::os::raw::c_int,
        levelx: ::std::os::raw::c_int,
        levely: ::std::os::raw::c_int,
        packed_data: *const ::std::os::raw::c_void,
        packed_size: u64,
        unpacked_size: u64,
        sample_data: *const ::std::os::raw::c_void,
        sample_data_size: u64,
    ) -> exr_result_t;
}
pub const transcoding_pipeline_buffer_id_EXR_TRANSCODE_BUFFER_PACKED:
    transcoding_pipeline_buffer_id = 0;
pub const transcoding_pipeline_buffer_id_EXR_TRANSCODE_BUFFER_UNPACKED:
    transcoding_pipeline_buffer_id = 1;
pub const transcoding_pipeline_buffer_id_EXR_TRANSCODE_BUFFER_COMPRESSED:
    transcoding_pipeline_buffer_id = 2;
pub const transcoding_pipeline_buffer_id_EXR_TRANSCODE_BUFFER_SCRATCH1:
    transcoding_pipeline_buffer_id = 3;
pub const transcoding_pipeline_buffer_id_EXR_TRANSCODE_BUFFER_SCRATCH2:
    transcoding_pipeline_buffer_id = 4;
pub const transcoding_pipeline_buffer_id_EXR_TRANSCODE_BUFFER_PACKED_SAMPLES:
    transcoding_pipeline_buffer_id = 5;
pub const transcoding_pipeline_buffer_id_EXR_TRANSCODE_BUFFER_SAMPLES:
    transcoding_pipeline_buffer_id = 6;
#[doc = " Enum for use in a custom allocator in the encode / decode pipelines"]
#[doc = " (i.e. so the implementor knows whether to allocate on which device"]
#[doc = " based on the buffer disposition)"]
pub type transcoding_pipeline_buffer_id = ::std::os::raw::c_uint;
#[doc = " @brief Structure for negotiating buffers when decoding / encoding"]
#[doc = " chunks of data"]
#[doc = ""]
#[doc = " This is generic and meant to negotiate exr data bi-directionally,"]
#[doc = " in that the same structure is used for both decoding and encoding"]
#[doc = " chunks for read and write, respectively."]
#[doc = ""]
#[doc = " The first half of the structure will be filled by the library, and"]
#[doc = " the caller is expected to fill the second half appropriately."]
#[repr(C)]
pub struct exr_coding_channel_info_t {
    #[doc = " channel name"]
    #[doc = ""]
    #[doc = " This is provided as a convenient reference. Do not free, this"]
    #[doc = " refers to the internal data structure in the context."]
    pub channel_name: *const ::std::os::raw::c_char,
    #[doc = " number of lines for this channel in this chunk"]
    #[doc = ""]
    #[doc = " May be 0 or less than overall image height based on sampling"]
    #[doc = " (i.e. when in 4:2:0 type sampling)"]
    pub height: i32,
    #[doc = " width in pixel count"]
    #[doc = ""]
    #[doc = " May be 0 or less than overall image width based on sampling"]
    #[doc = " (i.e. 4:2:2 will have some channels have fewer values)"]
    pub width: i32,
    #[doc = " horizontal subsampling information"]
    pub x_samples: i32,
    #[doc = " vertical subsampling information"]
    pub y_samples: i32,
    #[doc = " linear flag from channel definition (used by b44)"]
    pub p_linear: u8,
    #[doc = " how many bytes per pixel this channel consumes (i.e. 2 for"]
    #[doc = " float16, 4 for float32 / uint32)"]
    pub bytes_per_element: i8,
    #[doc = " small form of exr_pixel_type_t enum (EXR_PIXEL_UINT/HALF/FLOAT)"]
    pub data_type: u16,
    #[doc = " how many bytes per pixel the input is or output should be"]
    #[doc = " (i.e. 2 for float16, 4 for float32 / uint32). Defaults to same"]
    #[doc = " size as input"]
    pub user_bytes_per_element: i16,
    #[doc = " small form of exr_pixel_type_t enum"]
    #[doc = " (EXR_PIXEL_UINT/HALF/FLOAT). Defaults to same type as input"]
    pub user_data_type: u16,
    #[doc = " increment to get to next pixel"]
    #[doc = ""]
    #[doc = " This is in bytes. Must be specified when the decode pointer is"]
    #[doc = " specified (and always for encode)."]
    #[doc = ""]
    #[doc = " This is useful for implementing transcoding generically of"]
    #[doc = " planar or interleaved data. For planar data, where the layout"]
    #[doc = " is RRRRRGGGGGBBBBB, you can pass in 1 * bytes per component"]
    pub user_pixel_stride: i32,
    #[doc = " When lines > 1 for a chunk, this is the increment used to get"]
    #[doc = " from beginning of line to beginning of next line."]
    #[doc = ""]
    #[doc = " This is in bytes. Must be specified when the decode pointer is"]
    #[doc = " specified (and always for encode)."]
    pub user_line_stride: i32,
    pub __bindgen_anon_1: exr_coding_channel_info_t__bindgen_ty_1,
}
#[doc = " This data member has different requirements reading vs"]
#[doc = " writing. When reading, if this is left as NULL, the channel"]
#[doc = " will be skipped during read and not filled in.  During a write"]
#[doc = " operation, this pointer is considered const and not"]
#[doc = " modified. To make this more clear, a union is used here."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union exr_coding_channel_info_t__bindgen_ty_1 {
    pub decode_to_ptr: *mut u8,
    pub encode_from_ptr: *const u8,
}
#[test]
fn bindgen_test_layout_exr_coding_channel_info_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<exr_coding_channel_info_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(exr_coding_channel_info_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<exr_coding_channel_info_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(exr_coding_channel_info_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_coding_channel_info_t__bindgen_ty_1>()))
                .decode_to_ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t__bindgen_ty_1),
            "::",
            stringify!(decode_to_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_coding_channel_info_t__bindgen_ty_1>()))
                .encode_from_ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t__bindgen_ty_1),
            "::",
            stringify!(encode_from_ptr)
        )
    );
}
#[test]
fn bindgen_test_layout_exr_coding_channel_info_t() {
    assert_eq!(
        ::std::mem::size_of::<exr_coding_channel_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(exr_coding_channel_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<exr_coding_channel_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(exr_coding_channel_info_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_coding_channel_info_t>())).channel_name
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(channel_name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_coding_channel_info_t>())).height
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_coding_channel_info_t>())).width
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_coding_channel_info_t>())).x_samples
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(x_samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_coding_channel_info_t>())).y_samples
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(y_samples)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_coding_channel_info_t>())).p_linear
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(p_linear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_coding_channel_info_t>()))
                .bytes_per_element as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(bytes_per_element)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_coding_channel_info_t>())).data_type
                as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(data_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_coding_channel_info_t>()))
                .user_bytes_per_element as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(user_bytes_per_element)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_coding_channel_info_t>())).user_data_type
                as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(user_data_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_coding_channel_info_t>()))
                .user_pixel_stride as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(user_pixel_stride)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<exr_coding_channel_info_t>()))
                .user_line_stride as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(exr_coding_channel_info_t),
            "::",
            stringify!(user_line_stride)
        )
    );
}
#[doc = " Structure meant to be used on a per-thread basis for reading exr data"]
#[doc = ""]
#[doc = " As should be obvious, this structure is NOT thread safe, but rather"]
#[doc = " meant to be used by separate threads, which can all be accessing"]
#[doc = " the same context concurrently."]
#[repr(C)]
pub struct _exr_decode_pipeline {
    #[doc = " the output channel information for this chunk"]
    #[doc = ""]
    #[doc = " User is expected to fill the channel pointers for the desired"]
    #[doc = " output channels (any that are NULL will be skipped) if you are"]
    #[doc = " going to use \\ref exr_choose_unpack_routine. If all that is"]
    #[doc = " desired is to read and decompress the data, this can be left"]
    #[doc = " uninitialized."]
    #[doc = ""]
    #[doc = " Describes the channel information. This information is"]
    #[doc = " allocated dynamically during \\ref exr_initialize_decoding"]
    pub channels: *mut exr_coding_channel_info_t,
    pub channel_count: i16,
    #[doc = " Decode flags to control the behavior"]
    pub decode_flags: u16,
    #[doc = " copy of the parameters given to the initialize / update for convenience"]
    pub part_index: ::std::os::raw::c_int,
    pub context: exr_const_context_t,
    pub chunk: exr_chunk_info_t,
    #[doc = " can be used by the user to pass custom context data through"]
    #[doc = " the decode pipeline"]
    pub decoding_user_data: *mut ::std::os::raw::c_void,
    #[doc = " the (compressed) buffer."]
    #[doc = ""]
    #[doc = " If null, will be allocated during the run of the pipeline."]
    #[doc = ""]
    #[doc = " If the caller wishes to take control of the buffer, simple"]
    #[doc = " adopt the pointer and set it to null here. Be cognizant of any"]
    #[doc = " custom allocators."]
    pub packed_buffer: *mut ::std::os::raw::c_void,
    #[doc = " used when re-using the same decode pipeline struct to know if"]
    #[doc = " chunk is changed size whether current buffer is large enough"]
    pub packed_alloc_size: size_t,
    #[doc = " the decompressed buffer (unpacked_size from the chunk block"]
    #[doc = " info), but still packed into storage order, only needed for"]
    #[doc = " compressed files"]
    #[doc = ""]
    #[doc = " If null, will be allocated during the run of the pipeline when"]
    #[doc = " needed."]
    #[doc = ""]
    #[doc = " If the caller wishes to take control of the buffer, simple"]
    #[doc = " adopt the pointer and set it to null here. Be cognizant of any"]
    #[doc = " custom allocators."]
    pub unpacked_buffer: *mut ::std::os::raw::c_void,
    #[doc = " used when re-using the same decode pipeline struct to know if"]
    #[doc = " chunk is changed size whether current buffer is large enough"]
    pub unpacked_alloc_size: size_t,
    #[doc = " for deep or other non-image data */"]
    pub packed_sample_count_table: *mut ::std::os::raw::c_void,
    pub packed_sample_count_alloc_size: size_t,
    #[doc = " usable, native sample count table. Depending on the flag set"]
    #[doc = " above, will be decoded to either a cumulative list (n, n+m,"]
    #[doc = " n+m+o, ...), or an individual table (n, m, o, ...). As an"]
    #[doc = " optimization, if the latter individual count table is chosen,"]
    #[doc = " an extra int32_t will be allocated at the end of the table to"]
    #[doc = " contain the total count of samples, so the table will be n+1"]
    #[doc = " samples in size"]
    pub sample_count_table: *mut i32,
    pub sample_count_alloc_size: size_t,
    #[doc = " a scratch buffer of unpacked_size for intermediate results"]
    #[doc = ""]
    #[doc = " If null, will be allocated during the run of the pipeline when"]
    #[doc = " needed."]
    #[doc = ""]
    #[doc = " If the caller wishes to take control of the buffer, simple"]
    #[doc = " adopt the pointer and set it to null here. Be cognizant of any"]
    #[doc = " custom allocators."]
    pub scratch_buffer_1: *mut ::std::os::raw::c_void,
    #[doc = " used when re-using the same decode pipeline struct to know if"]
    #[doc = " chunk is changed size whether current buffer is large enough"]
    pub scratch_alloc_size_1: size_t,
    #[doc = " some decompression routines may need a second scratch buffer (i.e. zlib)"]
    #[doc = ""]
    #[doc = " If null, will be allocated during the run of the pipeline when"]
    #[doc = " needed."]
    #[doc = ""]
    #[doc = " If the caller wishes to take control of the buffer, simple"]
    #[doc = " adopt the pointer and set it to null here. Be cognizant of any"]
    #[doc = " custom allocators."]
    pub scratch_buffer_2: *mut ::std::os::raw::c_void,
    #[doc = " used when re-using the same decode pipeline struct to know if"]
    #[doc = " chunk is changed size whether current buffer is large enough"]
    pub scratch_alloc_size_2: size_t,
    #[doc = " enables a custom allocator for the different buffers (i.e. if"]
    #[doc = " decoding on a GPU). If NULL, will use the allocator from the"]
    #[doc = " context"]
    pub alloc_fn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: transcoding_pipeline_buffer_id,
            arg2: size_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " enables a custom allocator for the different buffers (i.e. if"]
    #[doc = " decoding on a GPU). If NULL, will use the allocator from the"]
    #[doc = " context"]
    pub free_fn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: transcoding_pipeline_buffer_id,
            arg2: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Function chosen to read chunk data from the context."]
    #[doc = ""]
    #[doc = " Initialized to a default generic read routine, may be updated"]
    #[doc = " based on channel information when \\ref"]
    #[doc = " exr_choose_default_routines is called. This is done such that"]
    #[doc = " if the file is uncompressed and the output channel data is"]
    #[doc = " planar and the same type, the read function can read straight"]
    #[doc = " into the output channels, getting closer to a zero-copy"]
    #[doc = " operation. Otherwise a more traditional read, decompress, then"]
    #[doc = " unpack pipeline will be used with a default reader."]
    #[doc = ""]
    #[doc = " This is allowed to be overridden, but probably is not necessary"]
    #[doc = " in most scenarios"]
    pub read_fn: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: *mut _exr_decode_pipeline,
        ) -> exr_result_t,
    >,
    #[doc = " Function chosen based on the compression type of the part to"]
    #[doc = " decompress data."]
    #[doc = ""]
    #[doc = " If the user has a custom decompression method for the"]
    #[doc = " compression on this part, this can be changed after"]
    #[doc = " initialization."]
    #[doc = ""]
    #[doc = " If only compressed data is desired, then assign this to NULL"]
    #[doc = " after initialization."]
    pub decompress_fn: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: *mut _exr_decode_pipeline,
        ) -> exr_result_t,
    >,
    #[doc = " Function which can be provided if you have bespoke handling for"]
    #[doc = " non-image data and need to re-allocate the data to handle the"]
    #[doc = " about-to-be unpacked data."]
    #[doc = ""]
    #[doc = " If left NULL, will assume the memory pointed to by the channel"]
    #[doc = " pointers is sufficient"]
    pub realloc_nonimage_data_fn: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: *mut _exr_decode_pipeline,
        ) -> exr_result_t,
    >,
    #[doc = " Function chosen based on the output layout of the channels of the part to"]
    #[doc = " decompress data."]
    #[doc = ""]
    #[doc = " This will be NULL after initialization, until the user"]
    #[doc = " specifies a custom routine, or initializes the channel data and"]
    #[doc = " calls \\ref exr_choose_unpack_routine."]
    #[doc = ""]
    #[doc = " If only compressed data is desired, then leave or assign this"]
    #[doc = " to NULL after initialization."]
    pub unpack_and_convert_fn: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: *mut _exr_decode_pipeline,
        ) -> exr_result_t,
    >,
    #[doc = " Small stash of channel info values. This is faster than calling"]
    #[doc = " malloc when the channel count in the part is small (RGBAZ),"]
    #[doc = " which is super common, however if there are a large number of"]
    #[doc = " channels, it will allocate space for that, so do not rely on"]
    #[doc = " this being used"]
    pub _quick_chan_store: [exr_coding_channel_info_t; 5usize],
}
#[test]
fn bindgen_test_layout__exr_decode_pipeline() {
    assert_eq!(
        ::std::mem::size_of::<_exr_decode_pipeline>(),
        480usize,
        concat!("Size of: ", stringify!(_exr_decode_pipeline))
    );
    assert_eq!(
        ::std::mem::align_of::<_exr_decode_pipeline>(),
        8usize,
        concat!("Alignment of ", stringify!(_exr_decode_pipeline))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).channels
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).channel_count
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(channel_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).decode_flags
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(decode_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).part_index
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(part_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).context as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).chunk as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(chunk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).decoding_user_data
                as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(decoding_user_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).packed_buffer
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(packed_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).packed_alloc_size
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(packed_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).unpacked_buffer
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(unpacked_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).unpacked_alloc_size
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(unpacked_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>()))
                .packed_sample_count_table as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(packed_sample_count_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>()))
                .packed_sample_count_alloc_size as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(packed_sample_count_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).sample_count_table
                as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(sample_count_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>()))
                .sample_count_alloc_size as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(sample_count_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).scratch_buffer_1
                as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(scratch_buffer_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>()))
                .scratch_alloc_size_1 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(scratch_alloc_size_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).scratch_buffer_2
                as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(scratch_buffer_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>()))
                .scratch_alloc_size_2 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(scratch_alloc_size_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).alloc_fn
                as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(alloc_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).free_fn as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(free_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).read_fn as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(read_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>())).decompress_fn
                as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(decompress_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>()))
                .realloc_nonimage_data_fn as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(realloc_nonimage_data_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>()))
                .unpack_and_convert_fn as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(unpack_and_convert_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_decode_pipeline>()))._quick_chan_store
                as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_decode_pipeline),
            "::",
            stringify!(_quick_chan_store)
        )
    );
}
#[doc = " Structure meant to be used on a per-thread basis for reading exr data"]
#[doc = ""]
#[doc = " As should be obvious, this structure is NOT thread safe, but rather"]
#[doc = " meant to be used by separate threads, which can all be accessing"]
#[doc = " the same context concurrently."]
pub type exr_decode_pipeline_t = _exr_decode_pipeline;
extern "C" {
    #[doc = " Initialize the decoding pipeline structure with the channel info"]
    #[doc = " for the specified part, and the first block to be read."]
    #[doc = ""]
    #[doc = " NB: The \\ref unpack_and_convert_fn will be NULL after this. If that"]
    #[doc = " stage is desired, initialize the channel output information and"]
    #[doc = " call \\ref exr_choose_unpack_routine"]
    pub fn exr_decoding_initialize(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        decode: *mut exr_decode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Given an initialized decode pipeline, find appropriate functions"]
    #[doc = " to read and shuffle / convert data into the defined channel outputs"]
    #[doc = ""]
    #[doc = " Calling this is not required if custom routines will be used, or if"]
    #[doc = " just the raw compressed data is desired. Although in that scenario,"]
    #[doc = " it is probably easier to just read the chunk directly using \\ref"]
    #[doc = " exr_read_chunk"]
    pub fn exr_decoding_choose_default_routines(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        decode: *mut exr_decode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Given a decode pipeline previously initialized, update it for the"]
    #[doc = " new chunk to be read."]
    #[doc = ""]
    #[doc = " In this manner, memory buffers can be re-used to avoid continual"]
    #[doc = " malloc / free calls. Further, it allows the previous choices for"]
    #[doc = " the various functions to be quickly re-used."]
    pub fn exr_decoding_update(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        decode: *mut exr_decode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Execute the decoding pipeline"]
    pub fn exr_decoding_run(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        decode: *mut exr_decode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Free any intermediate memory in the decoding pipeline"]
    #[doc = ""]
    #[doc = " This does *not* free any pointers referred to in the channel info"]
    #[doc = " areas, but rather only the intermediate buffers and memory needed"]
    #[doc = " for the structure itself."]
    pub fn exr_decoding_destroy(
        ctxt: exr_const_context_t,
        decode: *mut exr_decode_pipeline_t,
    ) -> exr_result_t;
}
#[doc = " Structure meant to be used on a per-thread basis for writing exr data"]
#[doc = ""]
#[doc = " As should be obvious, this structure is NOT thread safe, but rather"]
#[doc = " meant to be used by separate threads, which can all be accessing"]
#[doc = " the same context concurrently."]
#[repr(C)]
pub struct _exr_encode_pipeline {
    #[doc = " the output channel information for this chunk"]
    #[doc = ""]
    #[doc = " User is expected to fill the channel pointers for the input"]
    #[doc = " channels. For writing, all channels must be initialized prior"]
    #[doc = " to using \\ref exr_choose_pack_routine. If a custom pack routine"]
    #[doc = " is written, that is up to the implementor."]
    #[doc = ""]
    #[doc = " Describes the channel information. This information is"]
    #[doc = " allocated dynamically during \\ref exr_initialize_encoding"]
    pub channels: *mut exr_coding_channel_info_t,
    pub channel_count: i16,
    #[doc = " Encode flags to control the behavior"]
    pub encode_flags: u16,
    #[doc = " copy of the parameters given to the initialize / update for convenience"]
    pub part_index: ::std::os::raw::c_int,
    pub context: exr_const_context_t,
    pub chunk: exr_chunk_info_t,
    #[doc = " can be used by the user to pass custom context data through"]
    #[doc = " the encode pipeline"]
    pub encoding_user_data: *mut ::std::os::raw::c_void,
    #[doc = " the packed buffer where individual channels have been put into here."]
    #[doc = ""]
    #[doc = " If null, will be allocated during the run of the pipeline."]
    #[doc = ""]
    #[doc = " If the caller wishes to take control of the buffer, simple"]
    #[doc = " adopt the pointer and set it to null here. Be cognizant of any"]
    #[doc = " custom allocators."]
    pub packed_buffer: *mut ::std::os::raw::c_void,
    #[doc = " differing from the allocation size, the number of actual bytes"]
    pub packed_bytes: u64,
    #[doc = " used when re-using the same encode pipeline struct to know if"]
    #[doc = " chunk is changed size whether current buffer is large enough"]
    #[doc = ""]
    #[doc = " If null, will be allocated during the run of the pipeline."]
    #[doc = ""]
    #[doc = " If the caller wishes to take control of the buffer, simple"]
    #[doc = " adopt the pointer and set it to null here. Be cognizant of any"]
    #[doc = " custom allocators."]
    pub packed_alloc_size: size_t,
    #[doc = " for deep data. NB: the members NOT const because we need to"]
    #[doc = " temporarily swap it to xdr order and restore it (to avoid a"]
    #[doc = " duplicate buffer allocation)"]
    #[doc = ""]
    #[doc = " Depending on the flag set above, will be treated either as a"]
    #[doc = " cumulative list (n, n+m, n+m+o, ...), or an individual table"]
    #[doc = " (n, m, o, ...)."]
    pub sample_count_table: *mut i32,
    #[doc = " allocated table size (to avoid re-allocations). Number of"]
    #[doc = " samples must always be width * height for the chunk"]
    pub sample_count_alloc_size: size_t,
    #[doc = " packed sample table (i.e. compressed, raw on disk"]
    #[doc = " representation) for deep or other non-image data"]
    pub packed_sample_count_table: *mut ::std::os::raw::c_void,
    #[doc = " Number of bytes to write (actual size) for the"]
    #[doc = " packed_sample_count_table"]
    pub packed_sample_count_bytes: size_t,
    #[doc = " Allocated size (to avoid re-allocations) for the"]
    #[doc = " packed_sample_count_table"]
    pub packed_sample_count_alloc_size: size_t,
    #[doc = " the compressed buffer, only needed for"]
    #[doc = " compressed files"]
    #[doc = ""]
    #[doc = " If null, will be allocated during the run of the pipeline when"]
    #[doc = " needed."]
    #[doc = ""]
    #[doc = " If the caller wishes to take control of the buffer, simple"]
    #[doc = " adopt the pointer and set it to null here. Be cognizant of any"]
    #[doc = " custom allocators."]
    pub compressed_buffer: *mut ::std::os::raw::c_void,
    #[doc = " must be filled in as the pipeline runs to inform the writing"]
    #[doc = " software about the compressed size of the chunk (if it is an"]
    #[doc = " uncompressed file or the compression would make the file"]
    #[doc = " larger, it is expected to be the packed_buffer)"]
    #[doc = ""]
    #[doc = " If the caller wishes to take control of the buffer, simple"]
    #[doc = " adopt the pointer and set it to zero here. Be cognizant of any"]
    #[doc = " custom allocators."]
    pub compressed_bytes: size_t,
    #[doc = " used when re-using the same encode pipeline struct to know if"]
    #[doc = " chunk is changed size whether current buffer is large enough"]
    #[doc = ""]
    #[doc = " If null, will be allocated during the run of the pipeline when"]
    #[doc = " needed."]
    #[doc = ""]
    #[doc = " If the caller wishes to take control of the buffer, simple"]
    #[doc = " adopt the pointer and set it to zero here. Be cognizant of any"]
    #[doc = " custom allocators."]
    pub compressed_alloc_size: size_t,
    #[doc = " a scratch buffer for intermediate results"]
    #[doc = ""]
    #[doc = " If null, will be allocated during the run of the pipeline when"]
    #[doc = " needed."]
    #[doc = ""]
    #[doc = " If the caller wishes to take control of the buffer, simple"]
    #[doc = " adopt the pointer and set it to null here. Be cognizant of any"]
    #[doc = " custom allocators."]
    pub scratch_buffer_1: *mut ::std::os::raw::c_void,
    #[doc = " used when re-using the same encode pipeline struct to know if"]
    #[doc = " chunk is changed size whether current buffer is large enough"]
    #[doc = ""]
    #[doc = " If null, will be allocated during the run of the pipeline when"]
    #[doc = " needed."]
    #[doc = ""]
    #[doc = " If the caller wishes to take control of the buffer, simple"]
    #[doc = " adopt the pointer and set it to null here. Be cognizant of any"]
    #[doc = " custom allocators."]
    pub scratch_alloc_size_1: size_t,
    #[doc = " some compression routines may need a second scratch buffer"]
    #[doc = ""]
    #[doc = " If null, will be allocated during the run of the pipeline when"]
    #[doc = " needed."]
    #[doc = ""]
    #[doc = " If the caller wishes to take control of the buffer, simple"]
    #[doc = " adopt the pointer and set it to null here. Be cognizant of any"]
    #[doc = " custom allocators."]
    pub scratch_buffer_2: *mut ::std::os::raw::c_void,
    #[doc = " used when re-using the same encode pipeline struct to know if"]
    #[doc = " chunk is changed size whether current buffer is large enough"]
    pub scratch_alloc_size_2: size_t,
    #[doc = " enables a custom allocator for the different buffers (i.e. if"]
    #[doc = " encoding on a GPU). If NULL, will use the allocator from the"]
    #[doc = " context"]
    pub alloc_fn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: transcoding_pipeline_buffer_id,
            arg2: size_t,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " enables a custom allocator for the different buffers (i.e. if"]
    #[doc = " encoding on a GPU). If NULL, will use the allocator from the"]
    #[doc = " context"]
    pub free_fn: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: transcoding_pipeline_buffer_id,
            arg2: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Function chosen based on the output layout of the channels of the part to"]
    #[doc = " decompress data."]
    #[doc = ""]
    #[doc = " If the user has a custom method for the"]
    #[doc = " compression on this part, this can be changed after"]
    #[doc = " initialization."]
    pub convert_and_pack_fn: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: *mut _exr_encode_pipeline,
        ) -> exr_result_t,
    >,
    #[doc = " Function chosen based on the compression type of the part to"]
    #[doc = " compress data."]
    #[doc = ""]
    #[doc = " If the user has a custom compression method for the compression"]
    #[doc = " type on this part, this can be changed after initialization."]
    pub compress_fn: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: *mut _exr_encode_pipeline,
        ) -> exr_result_t,
    >,
    #[doc = " This routine is used when waiting for other threads to finish"]
    #[doc = " writing previous chunks such that this thread can write this"]
    #[doc = " chunk. This is used for parts which have a specified chunk"]
    #[doc = " ordering (increasing / decreasing y) and the chunks can not be"]
    #[doc = " written randomly (as could be true for uncompressed)."]
    #[doc = ""]
    #[doc = " This enables the calling application to contribute thread time"]
    #[doc = " to other computation as needed, or just use something like"]
    #[doc = " pthread_yield()."]
    #[doc = ""]
    #[doc = " By default, this routine will be assigned to a function which"]
    #[doc = " returns an error, failing the encode immediately. In this way,"]
    #[doc = " it assumes that there is only one thread being used for"]
    #[doc = " writing."]
    #[doc = ""]
    #[doc = " It is up to the user to provide an appropriate routine if"]
    #[doc = " performing multi-threaded writing."]
    pub yield_until_ready_fn: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: *mut _exr_encode_pipeline,
        ) -> exr_result_t,
    >,
    #[doc = " Function chosen to write chunk data to the context."]
    #[doc = ""]
    #[doc = " This is allowed to be overridden, but probably is not necessary"]
    #[doc = " in most scenarios"]
    pub write_fn: ::std::option::Option<
        unsafe extern "C" fn(
            pipeline: *mut _exr_encode_pipeline,
        ) -> exr_result_t,
    >,
    #[doc = " Small stash of channel info values. This is faster than calling"]
    #[doc = " malloc when the channel count in the part is small (RGBAZ),"]
    #[doc = " which is super common, however if there are a large number of"]
    #[doc = " channels, it will allocate space for that, so do not rely on"]
    #[doc = " this being used"]
    pub _quick_chan_store: [exr_coding_channel_info_t; 5usize],
}
#[test]
fn bindgen_test_layout__exr_encode_pipeline() {
    assert_eq!(
        ::std::mem::size_of::<_exr_encode_pipeline>(),
        504usize,
        concat!("Size of: ", stringify!(_exr_encode_pipeline))
    );
    assert_eq!(
        ::std::mem::align_of::<_exr_encode_pipeline>(),
        8usize,
        concat!("Alignment of ", stringify!(_exr_encode_pipeline))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).channels
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).channel_count
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(channel_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).encode_flags
                as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(encode_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).part_index
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(part_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).context as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).chunk as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(chunk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).encoding_user_data
                as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(encoding_user_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).packed_buffer
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(packed_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).packed_bytes
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(packed_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).packed_alloc_size
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(packed_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).sample_count_table
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(sample_count_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>()))
                .sample_count_alloc_size as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(sample_count_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>()))
                .packed_sample_count_table as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(packed_sample_count_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>()))
                .packed_sample_count_bytes as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(packed_sample_count_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>()))
                .packed_sample_count_alloc_size as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(packed_sample_count_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).compressed_buffer
                as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(compressed_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).compressed_bytes
                as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(compressed_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>()))
                .compressed_alloc_size as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(compressed_alloc_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).scratch_buffer_1
                as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(scratch_buffer_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>()))
                .scratch_alloc_size_1 as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(scratch_alloc_size_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).scratch_buffer_2
                as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(scratch_buffer_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>()))
                .scratch_alloc_size_2 as *const _ as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(scratch_alloc_size_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).alloc_fn
                as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(alloc_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).free_fn as *const _
                as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(free_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).convert_and_pack_fn
                as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(convert_and_pack_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).compress_fn
                as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(compress_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>()))
                .yield_until_ready_fn as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(yield_until_ready_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>())).write_fn
                as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(write_fn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_exr_encode_pipeline>()))._quick_chan_store
                as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_exr_encode_pipeline),
            "::",
            stringify!(_quick_chan_store)
        )
    );
}
#[doc = " Structure meant to be used on a per-thread basis for writing exr data"]
#[doc = ""]
#[doc = " As should be obvious, this structure is NOT thread safe, but rather"]
#[doc = " meant to be used by separate threads, which can all be accessing"]
#[doc = " the same context concurrently."]
pub type exr_encode_pipeline_t = _exr_encode_pipeline;
extern "C" {
    #[doc = " Initialize the encoding pipeline structure with the channel info"]
    #[doc = " for the specified part based on the chunk to be written"]
    #[doc = ""]
    #[doc = " NB: The \\ref pack_and_convert_fn will be NULL after this. If that"]
    #[doc = " stage is desired, initialize the channel output information and"]
    #[doc = " call \\ref exr_choose_unpack_routine"]
    pub fn exr_encoding_initialize(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        encode_pipe: *mut exr_encode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Given an initialized encode pipeline, find an appropriate"]
    #[doc = " function to shuffle and convert data into the defined channel"]
    #[doc = " outputs"]
    #[doc = ""]
    #[doc = " Calling this is not required if a custom routine will be used, or"]
    #[doc = " if just the raw decompressed data is desired."]
    pub fn exr_encoding_choose_default_routines(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        encode_pipe: *mut exr_encode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Given a encode pipeline previously initialized, update it for the"]
    #[doc = " new chunk to be written."]
    #[doc = ""]
    #[doc = " In this manner, memory buffers can be re-used to avoid continual"]
    #[doc = " malloc / free calls. Further, it allows the previous choices for"]
    #[doc = " the various functions to be quickly re-used."]
    pub fn exr_encoding_update(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        cinfo: *const exr_chunk_info_t,
        encode_pipe: *mut exr_encode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Execute the encoding pipeline"]
    pub fn exr_encoding_run(
        ctxt: exr_const_context_t,
        part_index: ::std::os::raw::c_int,
        encode_pipe: *mut exr_encode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Free any intermediate memory in the encoding pipeline"]
    #[doc = ""]
    #[doc = " This does NOT free any pointers referred to in the channel info"]
    #[doc = " areas, but rather only the intermediate buffers and memory needed"]
    #[doc = " for the structure itself."]
    pub fn exr_encoding_destroy(
        ctxt: exr_const_context_t,
        encode_pipe: *mut exr_encode_pipeline_t,
    ) -> exr_result_t;
}
extern "C" {
    #[doc = " Debug function: print to stdout the parts and attributes of the"]
    #[doc = " context @p c"]
    pub fn exr_print_context_info(
        c: exr_const_context_t,
        verbose: ::std::os::raw::c_int,
    ) -> exr_result_t;
}
